//#include "ldm.cuh"
//#include "ldm_cram.cuh"  // Include for d_decay_constants declaration
#include "cram/ldm_kernels_cram.cuh"  // Include for d_decay_constants declaration
#include "../include/ldm_nuclides.cuh"  // Include for d_decay_constants

// TEST FUNCTION - Simple Sr-92 → Y-92 decay for validation (NOT USED IN PRODUCTION)
// This function implements a simplified 2-nuclide decay chain for testing purposes
// Production code uses nuclear_decay_optimized() from ldm_cram.cuh


__device__ void nuclear_decay_optimized_inline(float* exp_matrix, float* concentration, bool no_clamp = false) {
    
    float result[MAX_NUCLIDES];
    
    // SIMPLE EXPONENTIAL DECAY for testing (Sr-92 → Y-92)
    for(int i = 0; i < MAX_NUCLIDES; i++) {
        result[i] = concentration[i];  // Start with input
    }
    
    // Apply simple Sr-92 → Y-92 decay for testing
    if(concentration[12] > 0.0f) {  // Sr-92 index
        float decay_rate_sr92 = 7.105e-05f;  // Sr-92 decay constant (1/s)
        float decay_factor = __expf(-decay_rate_sr92 * d_dt);
        float decayed_amount = concentration[12] * (1.0f - decay_factor);
        
        result[12] = concentration[12] * decay_factor;  // Sr-92 decay
        result[13] += decayed_amount;  // Y-92 production
    }
    
    
    // Copy result back with optional safety checks
    for(int i = 0; i < MAX_NUCLIDES; i++) {
        concentration[i] = result[i];
        
        if (!no_clamp) {
            // Safety check: handle small negative values (numerical noise)
            if(concentration[i] < 0.0f) {
                if(concentration[i] < -1e-12f) {
                    // Significant negative value detected
                }
                concentration[i] = 1e-30f;  // Small positive value instead of zero
            }
            
            // Handle very large values (potential overflow)
            if(concentration[i] > 1e30f) {
                concentration[i] = 1e30f;  // Clamp to large but reasonable value
            }
        } else {
            // No clamp mode: only check for NaN/Inf
            if(isnan(concentration[i]) || isinf(concentration[i])) {
                concentration[i] = 0.0f;
            }
        }
    }
}

__device__ float k_f_esi(float p, float t) {
    // Saturation specific humidity parameters used in enhanced Teten's formula.
    const float satfia = 1.0003f;
    const float satfib = 4.18e-8f;  // for p in Pa
    const float sateia = 611.15f;   // es in Pa
    const float sateib = 22.452f;
    const float sateic = 0.6f;

    // Calculate the factor 'f'
    float f = satfia + satfib * p;

    // Calculate the saturation water vapor pressure over ice
    float f_esi = f * sateia * expf(sateib * (t - 273.15f) / (t - sateic));

    return f_esi;
}

__device__ float k_f_esl(float p, float t) {
    // Constants
    const float satfwa = 1.0007f;
    const float satfwb = 3.46e-8f;  // for p in Pa
    const float satewa = 611.21f;   // es in Pa
    const float satewb = 17.502f;
    const float satewc = 32.18f;

    // Calculate the enhancement factor
    float f = satfwa + satfwb * p;

    // Calculate the saturation water vapor pressure over liquid water
    float f_esl = f * satewa * expf(satewb * (t - 273.15f) / (t - satewc));

    return f_esl;
}

__device__ float k_f_qvsat(float p, float t) {
    // Constants
    const float rd = 287.0f;  // Gas constant for dry air (m²/(s²*K))
    const float rv = 461.0f;  // Gas constant for water vapor (m²/(s²*K))
    const float rddrv = rd / rv;

    float fespt;
    
    // Determine which formula to use based on temperature
    if (t >= 253.15f) {  // Modification to account for supercooled water
        fespt = k_f_esl(p, t);  // Saturation vapor pressure over liquid water
    } else {
        fespt = k_f_esi(p, t);  // Saturation vapor pressure over ice
    }

    float denom = p - (1.0f - rddrv) * fespt;
    
    // Check for division by zero
    float f_qvsat;
    if (denom == 0.0f) {
        f_qvsat = 1.0f;
    } else {
        f_qvsat = rddrv * fespt / denom;
    }

    return f_qvsat;
}


__device__ float getRand(curandState* states){

        float rand_int = curand_uniform(states);
        return rand_int;
    }

__device__ float GaussianRand(curandState* states, float mu, float stdv){

        float u1 = getRand(states);
        float u2 = getRand(states);
                
        float mag = stdv*sqrt(-2.0*log(u1));
        return mag*cos(2*PI*u2)+mu;
    }

__global__ void init_curand_states(LDM::LDMpart* d_part, float t0){

        int idx = threadIdx.x + blockIdx.x * blockDim.x;
        if (idx >= d_nop) return;

        unsigned long long seed = static_cast<unsigned long long>((t0 + idx * 0.001f) * ULLONG_MAX);
        curandState localState;
        curand_init(seed, idx, 0, &localState);
        d_part[idx].randState[0] = localState;
    }

__device__ float Dynamic_viscosity(float temp){

    float c = 120.0;
    float t0 = 291.15;
    float eta0 = 1.827e-5;
    
    return eta0 * ((t0+c)/(temp+c)) * pow((temp/t0), 1.5);
}
__global__ void update_particle_flags(
    LDM::LDMpart* d_part, float activationRatio){

        int idx = blockIdx.x * blockDim.x + threadIdx.x;
        if (idx >= d_nop) return;

        LDM::LDMpart& p = d_part[idx];

        // Activate particles based on their index and current activationRatio
        int maxActiveIndex = int(d_nop * activationRatio);
        if (idx <= maxActiveIndex){
            p.flag = 1;
        }
    }

__global__ void update_particle_flags_ens(
    LDM::LDMpart* d_part, float activationRatio, int total_particles, int particles_per_ensemble){

        int idx = blockIdx.x * blockDim.x + threadIdx.x;
        if (idx >= total_particles) return;

        LDM::LDMpart& p = d_part[idx];

        int local_idx = idx % particles_per_ensemble;

        int maxActiveInEnsemble = int(particles_per_ensemble * activationRatio);
        if (p.timeidx <= maxActiveInEnsemble){
            p.flag = 1;
        }

        // DEBUG: Print activation info for particle 832 when activationRatio > 0.08
        if (idx == 832 && activationRatio > 0.08 && activationRatio < 0.15) {
            printf("[GPU_FLAG_ENS_T60] idx=%d, local_idx=%d, maxActive=%d, timeidx=%d, flag=%d (ratio=%.4f)\n",
                   idx, local_idx, maxActiveInEnsemble, p.timeidx, p.flag, activationRatio);
        }
    }

__global__ void move_part_by_wind_mpi(
    LDM::LDMpart* d_part, float t0, int rank, float* d_dryDep, float* d_wetDep, int mesh_nx, int mesh_ny,
    FlexUnis* device_meteorological_flex_unis0,
    FlexPres* device_meteorological_flex_pres0,
    FlexUnis* device_meteorological_flex_unis1,
    FlexPres* device_meteorological_flex_pres1){

        int idx = blockIdx.x * blockDim.x + threadIdx.x;
        if(idx >= d_nop) return;
        //if(idx != 0) return;  // Process all particles

        // Debug output disabled for performance

        LDM::LDMpart& p = d_part[idx];
        if(!p.flag) {
            return;
        }
        
        // Debug disabled for performance

        // Direct use of T_const instead of shared memory copy

        unsigned long long seed = static_cast<unsigned long long>(t0 * ULLONG_MAX);  // Time-dependent seed like CRAM
        curandState ss;
        curand_init(seed, idx, 0, &ss);


        int xidx, yidx;
        if(p.x*0.5 -179.0 >= 180.0) {
            xidx = 1;
            p.flag=false;
        }
        else xidx = int(p.x);
        yidx = int(p.y);

        int zidx = 0;
        int index;

        float fdump = 0;

        float hmix = 0;
        for(int i=0; i<2; i++){
            for(int j=0; j<2; j++){
                index = (xidx+i) * dimY_GFS + (yidx+j);
                hmix = max(hmix, device_meteorological_flex_unis0[index].HMIX);
                hmix = max(hmix, device_meteorological_flex_unis1[index].HMIX);
            }
        }

        // Debug disabled for performance

        float zeta = p.z/hmix;
        
        for(int i=0; i<dimZ_GFS; i++){
            if(d_flex_hgt[i] > p.z){
                zidx = i-1;  // Fixed: use lower level index like CRAM
                break;
            }
        }
        if(zidx < 0) zidx = 0;  // Ensure non-negative index

        float x0 = p.x-xidx;
        float y0 = p.y-yidx;
        
        // CRITICAL FIX: 높이 차이가 0에 가까우면 안전한 값으로 설정
        float height_diff = d_flex_hgt[zidx+1] - d_flex_hgt[zidx];
        float z0;
        if (abs(height_diff) < 1e-6f) {
            z0 = 0.0f; // 높이 차이가 거의 없으면 하위 레벨 사용
        } else {
            z0 = (p.z - d_flex_hgt[zidx]) / height_diff;
        }
        
        float x1 = 1-x0;
        float y1 = 1-y0;
        float z1 = 1-z0;
        float t1 = 1-t0;
        
        // Debug disabled for performance

        float ustr = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].USTR
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].USTR
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].USTR
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].USTR
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].USTR
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].USTR
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].USTR
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].USTR;

        float wstr = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].WSTR
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].WSTR
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].WSTR
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].WSTR
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].WSTR
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].WSTR
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].WSTR
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].WSTR;

        float obkl = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].OBKL
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].OBKL
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].OBKL
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].OBKL
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].OBKL
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].OBKL
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].OBKL
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].OBKL;

        obkl = 1/obkl;

        float vdep = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].VDEP
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].VDEP
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].VDEP
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].VDEP
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].VDEP
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].VDEP
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].VDEP
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].VDEP;

        float lsp = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].LPREC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].LPREC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].LPREC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].LPREC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].LPREC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].LPREC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].LPREC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].LPREC;

        float convp = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].CPREC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].CPREC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].CPREC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].CPREC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].CPREC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].CPREC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].CPREC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].CPREC;

        float cc = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].TCC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].TCC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].TCC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].TCC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].TCC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].TCC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].TCC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].TCC;


        // Debug: Check individual DRHO values before interpolation
        float drho_000 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO;
        float drho_100 = device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO;
        
        if (idx == 0 && isnan(drho_000)) {
            printf("[DRHO_DEBUG] DRHO_000 is NaN at indices [%d,%d,%d,%d]\n", xidx, yidx, zidx, 0);
        }
        if (idx == 0 && isnan(drho_100)) {
            printf("[DRHO_DEBUG] DRHO_100 is NaN at indices [%d,%d,%d,%d]\n", xidx+1, yidx, zidx, 0);
        }
        
        float drho_raw = x1*y1*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x0*y1*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x1*y0*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x0*y0*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x1*y1*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y1*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y0*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y0*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y1*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x0*y1*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x1*y0*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x0*y0*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x1*y1*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y1*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y0*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y0*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO;
        
        // Fix NaN issue: replace NaN with 0
        float drho = isnan(drho_raw) ? 0.0f : drho_raw;

        float rho = x1*y1*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x0*y1*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x1*y0*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x0*y0*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x1*y1*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y1*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y0*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y0*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y1*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x0*y1*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x1*y0*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x0*y0*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x1*y1*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y1*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y0*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y0*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO;

        // Optimize memory access by caching meteorological data points
        FlexPres met_p0[8], met_p1[8];
        
        // Cache meteorological data points with boundary checks
        // Ensure array indices are within bounds to prevent memory access violations
        int safe_xidx = min(xidx, dimX_GFS - 2);    // Ensure xidx+1 is valid
        int safe_yidx = min(yidx, dimY_GFS - 2);    // Ensure yidx+1 is valid
        int safe_zidx = min(zidx, dimZ_GFS - 2);    // Ensure zidx+1 is valid
        
        met_p0[0] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p0[1] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p0[2] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p0[3] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p0[4] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p0[5] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p0[6] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        met_p0[7] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        
        met_p1[0] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p1[1] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p1[2] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p1[3] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p1[4] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p1[5] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p1[6] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        met_p1[7] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        
        // Debug disabled for performance

        float temp = x1*y1*z1*t1*met_p0[0].TT + x0*y1*z1*t1*met_p0[1].TT + x1*y0*z1*t1*met_p0[2].TT + x0*y0*z1*t1*met_p0[3].TT
                    +x1*y1*z0*t1*met_p0[4].TT + x0*y1*z0*t1*met_p0[5].TT + x1*y0*z0*t1*met_p0[6].TT + x0*y0*z0*t1*met_p0[7].TT
                    +x1*y1*z1*t0*met_p1[0].TT + x0*y1*z1*t0*met_p1[1].TT + x1*y0*z1*t0*met_p1[2].TT + x0*y0*z1*t0*met_p1[3].TT
                    +x1*y1*z0*t0*met_p1[4].TT + x0*y1*z0*t0*met_p1[5].TT + x1*y0*z0*t0*met_p1[6].TT + x0*y0*z0*t0*met_p1[7].TT;

        float xwind = x1*y1*z1*t1*met_p0[0].UU + x0*y1*z1*t1*met_p0[1].UU + x1*y0*z1*t1*met_p0[2].UU + x0*y0*z1*t1*met_p0[3].UU
                     +x1*y1*z0*t1*met_p0[4].UU + x0*y1*z0*t1*met_p0[5].UU + x1*y0*z0*t1*met_p0[6].UU + x0*y0*z0*t1*met_p0[7].UU
                     +x1*y1*z1*t0*met_p1[0].UU + x0*y1*z1*t0*met_p1[1].UU + x1*y0*z1*t0*met_p1[2].UU + x0*y0*z1*t0*met_p1[3].UU
                     +x1*y1*z0*t0*met_p1[4].UU + x0*y1*z0*t0*met_p1[5].UU + x1*y0*z0*t0*met_p1[6].UU + x0*y0*z0*t0*met_p1[7].UU;

        float ywind = x1*y1*z1*t1*met_p0[0].VV + x0*y1*z1*t1*met_p0[1].VV + x1*y0*z1*t1*met_p0[2].VV + x0*y0*z1*t1*met_p0[3].VV
                     +x1*y1*z0*t1*met_p0[4].VV + x0*y1*z0*t1*met_p0[5].VV + x1*y0*z0*t1*met_p0[6].VV + x0*y0*z0*t1*met_p0[7].VV
                     +x1*y1*z1*t0*met_p1[0].VV + x0*y1*z1*t0*met_p1[1].VV + x1*y0*z1*t0*met_p1[2].VV + x0*y0*z1*t0*met_p1[3].VV
                     +x1*y1*z0*t0*met_p1[4].VV + x0*y1*z0*t0*met_p1[5].VV + x1*y0*z0*t0*met_p1[6].VV + x0*y0*z0*t0*met_p1[7].VV;

        float zwind = x1*y1*z1*t1*met_p0[0].WW + x0*y1*z1*t1*met_p0[1].WW + x1*y0*z1*t1*met_p0[2].WW + x0*y0*z1*t1*met_p0[3].WW
                     +x1*y1*z0*t1*met_p0[4].WW + x0*y1*z0*t1*met_p0[5].WW + x1*y0*z0*t1*met_p0[6].WW + x0*y0*z0*t1*met_p0[7].WW
                     +x1*y1*z1*t0*met_p1[0].WW + x0*y1*z1*t0*met_p1[1].WW + x1*y0*z1*t0*met_p1[2].WW + x0*y0*z1*t0*met_p1[3].WW
                     +x1*y1*z0*t0*met_p1[4].WW + x0*y1*z0*t0*met_p1[5].WW + x1*y0*z0*t0*met_p1[6].WW + x0*y0*z0*t0*met_p1[7].WW;

        // Debug wind calculation for NaN tracking
        if (idx == 0) {
            static int wind_debug_count = 0;
            if (wind_debug_count < 3) {
                printf("[WIND_CALC] Particle 0: xwind=%.6f, ywind=%.6f, zwind=%.6f (NaN: x=%d, y=%d, z=%d)\n", 
                       xwind, ywind, zwind, isnan(xwind), isnan(ywind), isnan(zwind));
                wind_debug_count++;
            }
        }

        // Critical debug: Only check for first timestep NaN issue
        if (idx == 0) {
            static int debug_count = 0;
            if (debug_count < 3) {
                printf("[CRITICAL] Particle 0: p.x=%.3f, p.y=%.3f, p.z=%.3f -> x1=%.3f, y1=%.3f, z1=%.3f -> xwind=%.3f\n", 
                       p.x, p.y, p.z, x1, y1, z1, xwind);
                printf("[DEBUG_Z_AFTER_CRITICAL] Particle 0: p.z=%.6f (NaN=%d)\n", p.z, isnan(p.z));
                debug_count++;
            }
        }



        float usig, vsig, wsig, dsw2;
        float uusig = 0, vvsig = 0, wwsig = 0;
        float Tu, Tv, Tw;
        float s1, s2;

        float dx = 0, dy = 0;
        float dxt = 0, dyt = 0;

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU;

        uusig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU;

        uusig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV;

        vvsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV;

        vvsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW;

        wwsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW;

        wwsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        // p.radi = 6.0e-1;
        // p.prho = 2500.0;

        float vis = Dynamic_viscosity(temp)/rho;
        float Re = p.radi/1.0e6*fabsf(d_vsetaver)/vis;
        float settold = d_vsetaver;
        float settling;
        float c_d;

        if(p.radi > 1.0e-10){
            for(int i=0; i<20; i++){
                if(Re<1.917) c_d = 24.0/Re;
                else if(Re<500.0) c_d = 18.5/pow(Re, 0.6);
                else c_d = 0.44;
    
                settling = -1.0*sqrt(4.0*_ga*p.radi/1.0e6*p.prho*d_cunningham/(3.0*c_d*rho));

                if(fabsf((settling-settold)/settling)<0.01) break;
    
                Re = p.radi/1.0e6*fabsf(settling)/vis;
                settold = settling;
            }
            zwind += settling;
        }


        p.w_wind = zwind;

        if(zeta <= 1.0) {

            if(hmix/abs(obkl) < 1.0){ // Neutral condition
                if(ustr<1.0e-4) ustr=1.0e-4;
                usig = 2.0*ustr*exp(-3.0e-4*p.z/ustr);
                if(usig<1.0e-5) usig=1.0e-5;
                vsig = 1.3*ustr*exp(-2.0e-4*p.z/ustr);
                if(vsig<1.0e-5) vsig=1.0e-5;
                wsig=vsig;

                dsw2 = -6.76e-4*ustr*exp(-4.0e-4*p.z/ustr);

                Tu=0.5*p.z/wsig/(1.0+1.5e-3*p.z/ustr);
                Tv=Tu;
                Tw=Tu;

            }

            else if(obkl < 0.0){ // Unstable condition
                usig = ustr*pow(12-0.5*hmix/obkl,1.0/3.0);
                if(usig<1.0e-6) usig=1.0e-6;
                vsig = usig;

                
                if(zeta < 0.03){
                    wsig = 0.9600*wstr*pow(3*zeta-obkl/hmix,1.0/3.0);
                    dsw2 = 1.8432*wstr*wstr/hmix*pow(3*zeta-obkl/hmix,-1.0/3.0);
                }
                else if(zeta < 0.40){
                    s1 = 0.9600*pow(3*zeta-obkl/hmix,1.0/3.0);
                    s2 = 0.7630*pow(zeta,0.175);
                    if(s1 < s2){
                        wsig = wstr*s1;
                        dsw2 = 1.8432*wstr*wstr/hmix*pow(3*zeta-obkl/hmix,-1.0/3.0);
                    }
                    else{
                        wsig = wstr*s2;
                        dsw2 = 0.203759*wstr*wstr/hmix*pow(zeta,-0.65);
                    }
                }
                else if(zeta < 0.96){
                    wsig = 0.722*wstr*pow(1-zeta,0.207);
                    dsw2 = -0.215812*wstr*wstr/hmix*pow(1-zeta,-0.586);
                }
                else if(zeta < 1.00){
                    wsig = 0.37*wstr;
                    dsw2 = 0.00;
                }

                if(wsig<1.0e-6) wsig=1.0e-6;

                Tu = 0.15*hmix/usig;
                Tv = Tu;

                if(p.z < abs(obkl)){
                    Tw = 0.1*p.z/(wsig*(0.55-0.38*abs(p.z/obkl)));
                } 
                else if(zeta < 0.1){
                    Tw = 0.59*p.z/wsig;
                }
                else{
                    Tw = 0.15*hmix/wsig*(1.0-exp(-5*zeta));
                }
            }

            else{ // Stable condition

                usig = 2.0*ustr*(1.0-zeta);
                vsig = 1.3*ustr*(1.0-zeta);
                if(usig<1.0e-6) usig=1.0e-6;
                if(vsig<1.0e-6) vsig=1.0e-6;
                wsig = vsig;

                dsw2 = 3.38*ustr*ustr*(zeta-1.0)/hmix;

                Tu = 0.15*hmix/usig*sqrt(zeta);
                Tv = 0.467*Tu;
                Tw = 0.1*hmix/wsig*pow(zeta,0.8);

            }

            if(Tu<10.0) Tu=10.0;
            if(Tv<10.0) Tv=10.0;
            if(Tw<30.0) Tw=30.0;

            float ux, uy, uz, rw;
            
            if(d_dt/Tu < 0.5) p.up = (1.0-d_dt/Tu)*p.up + curand_normal_double(&ss)*usig*sqrt(2.0*d_dt/Tu);
            else p.up = exp(-d_dt/Tu)*p.up + curand_normal_double(&ss)*usig*sqrt(1.0-exp(-d_dt/Tu)*exp(-d_dt/Tu));
                    
            if(d_dt/Tv < 0.5) p.vp = (1.0-d_dt/Tv)*p.vp + curand_normal_double(&ss)*vsig*sqrt(2.0*d_dt/Tv);
            else p.vp = exp(-d_dt/Tv)*p.vp + curand_normal_double(&ss)*vsig*sqrt(1.0-exp(-d_dt/Tv)*exp(-d_dt/Tv));    
        
            if(TURB_SWITCH){}
            else{
                rw = exp(-d_dt/Tw);
                float old_wp = p.wp;
                p.wp = (rw*p.wp + curand_normal_double(&ss)*sqrt(1.0-rw*rw)*wsig + Tw*(1.0-rw)*(dsw2+drho/rho*wsig*wsig))*p.dir;
                
                if (idx == 0) {
                    static int wp_debug_count = 0;
                    if (wp_debug_count < 3) {
                        printf("[WP_CALC] Particle 0: Tw=%.6f, rw=%.6f, old_wp=%.6f, wsig=%.6f, dsw2=%.6f, drho=%.6f, rho=%.6f, p.dir=%d, new_wp=%.6f (NaN=%d)\n", 
                               Tw, rw, old_wp, wsig, dsw2, drho, rho, p.dir, p.wp, isnan(p.wp));
                        wp_debug_count++;
                    }
                }
            }
            

            // Debug disabled for performance
            
            if (p.wp*d_dt < -p.z){
                p.dir = -1;
                float old_z = p.z;
                p.z = -p.z - p.wp*d_dt;
                if (idx == 0) {
                    static int reflect_debug1 = 0;
                    if (reflect_debug1 < 3) {
                        printf("[Z_REFLECT1] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                               old_z, p.wp, d_dt, p.z, isnan(p.z));
                        reflect_debug1++;
                    }
                }
            }
            else if (p.wp*d_dt > (hmix-p.z)){
                p.dir = -1;
                float old_z = p.z;
                p.z = -p.z - p.wp*d_dt + 2.*hmix;
                if (idx == 0) {
                    static int reflect_debug2 = 0;
                    if (reflect_debug2 < 3) {
                        printf("[Z_REFLECT2] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, hmix=%.6f, new_z=%.6f (NaN=%d)\n", 
                               old_z, p.wp, d_dt, hmix, p.z, isnan(p.z));
                        reflect_debug2++;
                    }
                }
            }
            else{
                p.dir = 1;
                p.z = p.z + p.wp*d_dt;
                if (idx == 0) {
                    static int reflect_debug3 = 0;
                    if (reflect_debug3 < 3) {
                        printf("[Z_NORMAL] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                               p.z - p.wp*d_dt, p.wp, d_dt, p.z, isnan(p.z));
                        reflect_debug3++;
                    }
                }
            }



            //p.z += p.wp*d_dt;

            dx += xwind*d_dt;
            dy += ywind*d_dt;
            dxt += p.up*d_dt;
            dyt += p.vp*d_dt;
            float old_z_zwind = p.z;
            p.z += zwind*d_dt;
            
            // Debug first particle z update for NaN tracking
            if (idx == 0) {
                static int z_debug_count = 0;
                if (z_debug_count < 3) {
                    printf("[Z_UPDATE1] Particle 0: old_z=%.6f, zwind=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                           old_z_zwind, zwind, d_dt, p.z, isnan(p.z));
                    z_debug_count++;
                }
            }

        }
        else{

            float ux, uy, uz;

            
            // if(p.z < trop){
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }
            // else if(p.z < trop+1000.0){
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }
            // else{
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }

            ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            uz = 0.0;

            // if(p.z < trop){
            //     ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            //     uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            //     uz = 0.0;
            // }
            // else if(p.z < trop+1000.0){
            //     ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt*(1-(p.z-trop)/1000.0));
            //     uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt*(1-(p.z-trop)/1000.0));
            //     uz = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.*d_strat/d_dt*(p.z-trop)/1000.0)+d_strat/1000.0;
            // }
            // else{
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.*d_strat/d_dt);
            // }
            

            dx += (xwind+ux)*d_dt;
            dy += (ywind+uy)*d_dt;
            float old_z_strat = p.z;
            p.z += (zwind+uz)*d_dt;
            
            // Debug second particle z update for NaN tracking
            if (idx == 0) {
                static int z_debug_count2 = 0;
                if (z_debug_count2 < 3) {
                    printf("[Z_UPDATE2] Particle 0: old_z=%.6f, zwind=%.6f, uz=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                           old_z_strat, zwind, uz, d_dt, p.z, isnan(p.z));
                    z_debug_count2++;
                }
            }
            
            if(p.z<0.0) {
                float old_z_neg = p.z;
                p.z=-p.z;
                if (idx == 0) {
                    static int z_debug_count3 = 0;
                    if (z_debug_count3 < 3) {
                        printf("[Z_UPDATE3] Particle 0: negative z correction: %.6f -> %.6f (NaN=%d)\n", 
                               old_z_neg, p.z, isnan(p.z));
                        z_debug_count3++;
                    }
                }
            }

        }

        float r = exp(-2.0*d_dt/static_cast<float>(time_interval));
        float rs = sqrt(1.0-r*r);

        if(p.z<0.0) {
            float old_z_final_neg = p.z;
            p.z=-p.z;
        }

        
        float wind = sqrt(xwind*xwind+ywind*ywind);

        dx += xwind/wind*dxt-ywind/wind*dyt;
        dy += ywind/wind*dxt+xwind/wind*dyt;

        //printf("s1= %f, s2= %f\n", xwind/wind*dxt-ywind/wind*dyt, ywind/wind*dxt+xwind/wind*dyt);

        s1 = 180.0/(0.5*r_earth*PI);// dxconst, dyconst
        s2 = s1/cos((p.y*0.5-90.0)*PI180);// cosfact

        //printf("dx= %f, dy= %f, s1= %f, s2= %f\n", dx, dy, s1, s2);
        //printf("dx= %f, dy= %f\n", dx*s2, dy*s1);
        p.x += dx*s2; //!!
        p.y += dy*s1; //!!
        

        if(p.z > d_flex_hgt[dimZ_GFS-1]) {
            float old_z_clamp = p.z;
            p.z = d_flex_hgt[dimZ_GFS-1]*0.999999;
        }

        float prob = 0.0;
        float decfact = 1.0;
        float prob_dry = 0.0f;

        if (d_drydep && p.z < 2.0f * _href) {
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP enabled: z=%.2f, href=%.2f, vdep=%.6f\n", p.z, _href, vdep);
            // }
            float arg = -vdep * d_dt / (2.0f * _href);
            prob_dry = clamp01(1.0f - __expf(arg));
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP calculation: arg=%.6f, exp(arg)=%.6f, prob_dry=%.6f\n", arg, __expf(arg), prob_dry);
            // }
        } 
        //else if (idx == 0 && tstep <= 3) {
        //     printf("[GPU] DRYDEP disabled or z too high: d_drydep=%d, z=%.2f\n", d_drydep, p.z);
        // }

        float clouds_v, clouds_h;

        if(t0<=0.5) {
            clouds_v = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].CLDS;
            clouds_h = device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].CLDH;
        }
        else{
            clouds_v = device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].CLDS;
            clouds_h = device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].CLDH;
        }

            float wet_removal = 0.0f;

            if (d_wetdep && (lsp >= 0.01f || convp >= 0.01f) && clouds_v > 1.0f) {
                // if (idx == 0 && tstep <= 3) {
                //     printf("[GPU] WETDEP enabled: lsp=%.3f, convp=%.3f, clouds=%.1f\n", lsp, convp, clouds_v);
                // }
                const float lfr[5] = {0.5f, 0.65f, 0.8f, 0.9f, 0.95f};
                const float cfr[5] = {0.4f, 0.55f, 0.7f, 0.8f, 0.9f};

                int weti = (lsp > 20.0f) ? 5 : (lsp > 8.0f) ? 4 : (lsp > 3.0f) ? 3 : (lsp > 1.0f) ? 2 : 1;
                int wetj = (convp > 20.0f) ? 5 : (convp > 8.0f) ? 4 : (convp > 3.0f) ? 3 : (convp > 1.0f) ? 2 : 1;

                float grfraction = 0.05f;
                if (lsp + convp > 0.0f) {
                    grfraction = fmaxf(0.05f, cc * (lsp * lfr[weti - 1] + convp * cfr[wetj - 1]) / (lsp + convp));
                }

                float prec = (lsp + convp) / grfraction;

                // 스캐빈징
                float wetscav = 0.0f;
                const float weta = 9.99999975e-5f;
                const float wetb = 0.800000012f;
                const float henry = p.drydep_vel;

                if (weta > 0.0f) {
                    if (clouds_v >= 4.0f) {
                        wetscav = weta * powf(prec, wetb);
                    } else {
                        float act_temp = (t0 <= 0.5f)
                            ? device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].TT
                            : device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].TT;
                        float cl = 2.0e-7f * powf(prec, 0.36f);
                        float S_i = (p.radi > 1.0e-10f)
                            ? (0.9f / cl)
                            : 1.0f / ((1.0f - cl) / (henry * (_rair / 3500.0f) * act_temp) + cl);
                        wetscav = S_i * prec / 3.6e6f / fmaxf(1.0f, clouds_h);
                    }
                }

                wet_removal = clamp01((1.0f - __expf(-wetscav * d_dt)) * grfraction);
            } 
            //else if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] WETDEP disabled or no precipitation: d_wetdep=%d, lsp=%.3f, convp=%.3f\n", d_wetdep, lsp, convp);
            // }

            if (d_raddecay) {
                // if (idx == 0 && tstep <= 5) {  // Only first particle, first few timesteps
                //     printf("[GPU] RADDECAY enabled: applying T matrix\n");
                // }
                //apply_T_once_rowmajor_60(T_const, p.concentrations);
                cram_decay_calculation(T_const, p.concentrations);
            } 
            // else if (idx == 0 && tstep <= 5) {
            //     printf("[GPU] RADDECAY disabled: skipping T matrix\n");
            // }


            if (d_wetdep && wet_removal > 0.0f) {
                #pragma unroll
                for (int i = 0; i < N_NUCLIDES; ++i) {
                    float c = p.concentrations[i];
                    if (c > 0.0f) p.concentrations[i] = c * (1.0f - wet_removal);
                }
            }


        if (d_drydep && prob_dry > 0.0f) {
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP applying: prob_dry=%.6f\n", prob_dry);
            // }
            
            #pragma unroll
            for (int i = 0; i < N_NUCLIDES; ++i) {
                float c = p.concentrations[i];
                if (c > 0.0f) p.concentrations[i] = c * (1.0f - prob_dry);
            }
            
        } 
        //else if (d_drydep && idx == 0 && tstep <= 3) {
        //     printf("[GPU] DRYDEP not applying: prob_dry=%.6f\n", prob_dry);
        // }


    float total = 0.0f;
    #pragma unroll
    for (int i = 0; i < N_NUCLIDES; ++i) {
        float c = p.concentrations[i];
        c = isfinite(c) ? c : 0.0f;
        c = fminf(c, 1e20f);
        // ALLOW NEGATIVE CONCENTRATIONS for EKI algorithm
        // c = fmaxf(c, 0.0f);  // REMOVED: Don't clamp to zero
        p.concentrations[i] = c;
        total += c;
    }
    // ALLOW NEGATIVE TOTAL for EKI algorithm
    // p.conc = fminf(fmaxf(total, 0.0f), 1e20f);  // REMOVED: Don't clamp to zero
    p.conc = isfinite(total) ? fminf(total, 1e20f) : 0.0f;
    

        // Safety checks for wind components
        p.u_wind = isnan(xwind) ? 0.0f : xwind;
        p.v_wind = isnan(ywind) ? 0.0f : ywind;
        p.w_wind = isnan(zwind) ? 0.0f : zwind;

        // Final debug only for critical check
        if (idx == 0) {
            static int final_debug_count = 0;
            if (final_debug_count < 5) {
                printf("[FINAL] Particle 0: z=%.3f (NaN=%d)\n", p.z, isnan(p.z));
                final_debug_count++;
            }
        }

}

__global__ void move_part_by_wind_mpi_ens(
    LDM::LDMpart* d_part, float t0, int rank, float* d_dryDep, float* d_wetDep, int mesh_nx, int mesh_ny,
    FlexUnis* device_meteorological_flex_unis0,
    FlexPres* device_meteorological_flex_pres0,
    FlexUnis* device_meteorological_flex_unis1,
    FlexPres* device_meteorological_flex_pres1,
    int total_particles){

        int idx = blockIdx.x * blockDim.x + threadIdx.x;
        if(idx >= total_particles) return;
        //if(idx != 0) return;  // Process all particles

        // Debug output disabled for performance

        LDM::LDMpart& p = d_part[idx];
        if(!p.flag) {
            return;
        }
        
        // Debug disabled for performance

        // Direct use of T_const instead of shared memory copy

        unsigned long long seed = static_cast<unsigned long long>(t0 * ULLONG_MAX);  // Time-dependent seed like CRAM
        curandState ss;
        curand_init(seed, idx, 0, &ss);


        int xidx, yidx;
        if(p.x*0.5 -179.0 >= 180.0) {
            xidx = 1;
            p.flag=false;
        }
        else xidx = int(p.x);
        yidx = int(p.y);

        int zidx = 0;
        int index;

        float fdump = 0;

        float hmix = 0;
        for(int i=0; i<2; i++){
            for(int j=0; j<2; j++){
                index = (xidx+i) * dimY_GFS + (yidx+j);
                hmix = max(hmix, device_meteorological_flex_unis0[index].HMIX);
                hmix = max(hmix, device_meteorological_flex_unis1[index].HMIX);
            }
        }

        // Debug disabled for performance

        float zeta = p.z/hmix;
        
        for(int i=0; i<dimZ_GFS; i++){
            if(d_flex_hgt[i] > p.z){
                zidx = i-1;  // Fixed: use lower level index like CRAM
                break;
            }
        }
        if(zidx < 0) zidx = 0;  // Ensure non-negative index

        float x0 = p.x-xidx;
        float y0 = p.y-yidx;
        
        // CRITICAL FIX: 높이 차이가 0에 가까우면 안전한 값으로 설정
        float height_diff = d_flex_hgt[zidx+1] - d_flex_hgt[zidx];
        float z0;
        if (abs(height_diff) < 1e-6f) {
            z0 = 0.0f; // 높이 차이가 거의 없으면 하위 레벨 사용
        } else {
            z0 = (p.z - d_flex_hgt[zidx]) / height_diff;
        }
        
        float x1 = 1-x0;
        float y1 = 1-y0;
        float z1 = 1-z0;
        float t1 = 1-t0;
        
        // Debug disabled for performance

        float ustr = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].USTR
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].USTR
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].USTR
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].USTR
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].USTR
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].USTR
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].USTR
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].USTR;

        float wstr = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].WSTR
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].WSTR
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].WSTR
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].WSTR
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].WSTR
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].WSTR
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].WSTR
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].WSTR;

        float obkl = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].OBKL
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].OBKL
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].OBKL
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].OBKL
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].OBKL
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].OBKL
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].OBKL
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].OBKL;

        obkl = 1/obkl;

        float vdep = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].VDEP
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].VDEP
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].VDEP
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].VDEP
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].VDEP
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].VDEP
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].VDEP
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].VDEP;

        float lsp = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].LPREC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].LPREC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].LPREC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].LPREC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].LPREC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].LPREC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].LPREC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].LPREC;

        float convp = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].CPREC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].CPREC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].CPREC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].CPREC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].CPREC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].CPREC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].CPREC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].CPREC;

        float cc = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].TCC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].TCC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].TCC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].TCC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].TCC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].TCC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].TCC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].TCC;


        // Debug: Check individual DRHO values before interpolation
        float drho_000 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO;
        float drho_100 = device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO;
        
        if (idx == 0 && isnan(drho_000)) {
            printf("[DRHO_DEBUG] DRHO_000 is NaN at indices [%d,%d,%d,%d]\n", xidx, yidx, zidx, 0);
        }
        if (idx == 0 && isnan(drho_100)) {
            printf("[DRHO_DEBUG] DRHO_100 is NaN at indices [%d,%d,%d,%d]\n", xidx+1, yidx, zidx, 0);
        }
        
        float drho_raw = x1*y1*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x0*y1*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x1*y0*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x0*y0*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x1*y1*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y1*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y0*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y0*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y1*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x0*y1*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x1*y0*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x0*y0*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x1*y1*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y1*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y0*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y0*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO;
        
        // Fix NaN issue: replace NaN with 0
        float drho = isnan(drho_raw) ? 0.0f : drho_raw;

        float rho = x1*y1*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x0*y1*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x1*y0*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x0*y0*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x1*y1*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y1*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y0*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y0*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y1*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x0*y1*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x1*y0*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x0*y0*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x1*y1*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y1*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y0*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y0*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO;

        // Optimize memory access by caching meteorological data points
        FlexPres met_p0[8], met_p1[8];
        
        // Cache meteorological data points with boundary checks
        // Ensure array indices are within bounds to prevent memory access violations
        int safe_xidx = min(xidx, dimX_GFS - 2);    // Ensure xidx+1 is valid
        int safe_yidx = min(yidx, dimY_GFS - 2);    // Ensure yidx+1 is valid
        int safe_zidx = min(zidx, dimZ_GFS - 2);    // Ensure zidx+1 is valid
        
        met_p0[0] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p0[1] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p0[2] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p0[3] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p0[4] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p0[5] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p0[6] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        met_p0[7] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        
        met_p1[0] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p1[1] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p1[2] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p1[3] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p1[4] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p1[5] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p1[6] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        met_p1[7] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        
        // Debug disabled for performance

        float temp = x1*y1*z1*t1*met_p0[0].TT + x0*y1*z1*t1*met_p0[1].TT + x1*y0*z1*t1*met_p0[2].TT + x0*y0*z1*t1*met_p0[3].TT
                    +x1*y1*z0*t1*met_p0[4].TT + x0*y1*z0*t1*met_p0[5].TT + x1*y0*z0*t1*met_p0[6].TT + x0*y0*z0*t1*met_p0[7].TT
                    +x1*y1*z1*t0*met_p1[0].TT + x0*y1*z1*t0*met_p1[1].TT + x1*y0*z1*t0*met_p1[2].TT + x0*y0*z1*t0*met_p1[3].TT
                    +x1*y1*z0*t0*met_p1[4].TT + x0*y1*z0*t0*met_p1[5].TT + x1*y0*z0*t0*met_p1[6].TT + x0*y0*z0*t0*met_p1[7].TT;

        float xwind = x1*y1*z1*t1*met_p0[0].UU + x0*y1*z1*t1*met_p0[1].UU + x1*y0*z1*t1*met_p0[2].UU + x0*y0*z1*t1*met_p0[3].UU
                     +x1*y1*z0*t1*met_p0[4].UU + x0*y1*z0*t1*met_p0[5].UU + x1*y0*z0*t1*met_p0[6].UU + x0*y0*z0*t1*met_p0[7].UU
                     +x1*y1*z1*t0*met_p1[0].UU + x0*y1*z1*t0*met_p1[1].UU + x1*y0*z1*t0*met_p1[2].UU + x0*y0*z1*t0*met_p1[3].UU
                     +x1*y1*z0*t0*met_p1[4].UU + x0*y1*z0*t0*met_p1[5].UU + x1*y0*z0*t0*met_p1[6].UU + x0*y0*z0*t0*met_p1[7].UU;

        float ywind = x1*y1*z1*t1*met_p0[0].VV + x0*y1*z1*t1*met_p0[1].VV + x1*y0*z1*t1*met_p0[2].VV + x0*y0*z1*t1*met_p0[3].VV
                     +x1*y1*z0*t1*met_p0[4].VV + x0*y1*z0*t1*met_p0[5].VV + x1*y0*z0*t1*met_p0[6].VV + x0*y0*z0*t1*met_p0[7].VV
                     +x1*y1*z1*t0*met_p1[0].VV + x0*y1*z1*t0*met_p1[1].VV + x1*y0*z1*t0*met_p1[2].VV + x0*y0*z1*t0*met_p1[3].VV
                     +x1*y1*z0*t0*met_p1[4].VV + x0*y1*z0*t0*met_p1[5].VV + x1*y0*z0*t0*met_p1[6].VV + x0*y0*z0*t0*met_p1[7].VV;

        float zwind = x1*y1*z1*t1*met_p0[0].WW + x0*y1*z1*t1*met_p0[1].WW + x1*y0*z1*t1*met_p0[2].WW + x0*y0*z1*t1*met_p0[3].WW
                     +x1*y1*z0*t1*met_p0[4].WW + x0*y1*z0*t1*met_p0[5].WW + x1*y0*z0*t1*met_p0[6].WW + x0*y0*z0*t1*met_p0[7].WW
                     +x1*y1*z1*t0*met_p1[0].WW + x0*y1*z1*t0*met_p1[1].WW + x1*y0*z1*t0*met_p1[2].WW + x0*y0*z1*t0*met_p1[3].WW
                     +x1*y1*z0*t0*met_p1[4].WW + x0*y1*z0*t0*met_p1[5].WW + x1*y0*z0*t0*met_p1[6].WW + x0*y0*z0*t0*met_p1[7].WW;

        // Debug wind calculation for NaN tracking
        if (idx == 0) {
            static int wind_debug_count = 0;
            if (wind_debug_count < 3) {
                printf("[WIND_CALC] Particle 0: xwind=%.6f, ywind=%.6f, zwind=%.6f (NaN: x=%d, y=%d, z=%d)\n", 
                       xwind, ywind, zwind, isnan(xwind), isnan(ywind), isnan(zwind));
                wind_debug_count++;
            }
        }

        // Critical debug: Only check for first timestep NaN issue
        if (idx == 0) {
            static int debug_count = 0;
            if (debug_count < 3) {
                printf("[CRITICAL] Particle 0: p.x=%.3f, p.y=%.3f, p.z=%.3f -> x1=%.3f, y1=%.3f, z1=%.3f -> xwind=%.3f\n", 
                       p.x, p.y, p.z, x1, y1, z1, xwind);
                printf("[DEBUG_Z_AFTER_CRITICAL] Particle 0: p.z=%.6f (NaN=%d)\n", p.z, isnan(p.z));
                debug_count++;
            }
        }



        float usig, vsig, wsig, dsw2;
        float uusig = 0, vvsig = 0, wwsig = 0;
        float Tu, Tv, Tw;
        float s1, s2;

        float dx = 0, dy = 0;
        float dxt = 0, dyt = 0;

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU;

        uusig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU;

        uusig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV;

        vvsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV;

        vvsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW;

        wwsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW;

        wwsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        // p.radi = 6.0e-1;
        // p.prho = 2500.0;

        float vis = Dynamic_viscosity(temp)/rho;
        float Re = p.radi/1.0e6*fabsf(d_vsetaver)/vis;
        float settold = d_vsetaver;
        float settling;
        float c_d;

        if(p.radi > 1.0e-10){
            for(int i=0; i<20; i++){
                if(Re<1.917) c_d = 24.0/Re;
                else if(Re<500.0) c_d = 18.5/pow(Re, 0.6);
                else c_d = 0.44;
    
                settling = -1.0*sqrt(4.0*_ga*p.radi/1.0e6*p.prho*d_cunningham/(3.0*c_d*rho));

                if(fabsf((settling-settold)/settling)<0.01) break;
    
                Re = p.radi/1.0e6*fabsf(settling)/vis;
                settold = settling;
            }
            zwind += settling;
        }


        p.w_wind = zwind;

        if(zeta <= 1.0) {

            if(hmix/abs(obkl) < 1.0){ // Neutral condition
                if(ustr<1.0e-4) ustr=1.0e-4;
                usig = 2.0*ustr*exp(-3.0e-4*p.z/ustr);
                if(usig<1.0e-5) usig=1.0e-5;
                vsig = 1.3*ustr*exp(-2.0e-4*p.z/ustr);
                if(vsig<1.0e-5) vsig=1.0e-5;
                wsig=vsig;

                dsw2 = -6.76e-4*ustr*exp(-4.0e-4*p.z/ustr);

                Tu=0.5*p.z/wsig/(1.0+1.5e-3*p.z/ustr);
                Tv=Tu;
                Tw=Tu;

            }

            else if(obkl < 0.0){ // Unstable condition
                usig = ustr*pow(12-0.5*hmix/obkl,1.0/3.0);
                if(usig<1.0e-6) usig=1.0e-6;
                vsig = usig;

                
                if(zeta < 0.03){
                    wsig = 0.9600*wstr*pow(3*zeta-obkl/hmix,1.0/3.0);
                    dsw2 = 1.8432*wstr*wstr/hmix*pow(3*zeta-obkl/hmix,-1.0/3.0);
                }
                else if(zeta < 0.40){
                    s1 = 0.9600*pow(3*zeta-obkl/hmix,1.0/3.0);
                    s2 = 0.7630*pow(zeta,0.175);
                    if(s1 < s2){
                        wsig = wstr*s1;
                        dsw2 = 1.8432*wstr*wstr/hmix*pow(3*zeta-obkl/hmix,-1.0/3.0);
                    }
                    else{
                        wsig = wstr*s2;
                        dsw2 = 0.203759*wstr*wstr/hmix*pow(zeta,-0.65);
                    }
                }
                else if(zeta < 0.96){
                    wsig = 0.722*wstr*pow(1-zeta,0.207);
                    dsw2 = -0.215812*wstr*wstr/hmix*pow(1-zeta,-0.586);
                }
                else if(zeta < 1.00){
                    wsig = 0.37*wstr;
                    dsw2 = 0.00;
                }

                if(wsig<1.0e-6) wsig=1.0e-6;

                Tu = 0.15*hmix/usig;
                Tv = Tu;

                if(p.z < abs(obkl)){
                    Tw = 0.1*p.z/(wsig*(0.55-0.38*abs(p.z/obkl)));
                } 
                else if(zeta < 0.1){
                    Tw = 0.59*p.z/wsig;
                }
                else{
                    Tw = 0.15*hmix/wsig*(1.0-exp(-5*zeta));
                }
            }

            else{ // Stable condition

                usig = 2.0*ustr*(1.0-zeta);
                vsig = 1.3*ustr*(1.0-zeta);
                if(usig<1.0e-6) usig=1.0e-6;
                if(vsig<1.0e-6) vsig=1.0e-6;
                wsig = vsig;

                dsw2 = 3.38*ustr*ustr*(zeta-1.0)/hmix;

                Tu = 0.15*hmix/usig*sqrt(zeta);
                Tv = 0.467*Tu;
                Tw = 0.1*hmix/wsig*pow(zeta,0.8);

            }

            if(Tu<10.0) Tu=10.0;
            if(Tv<10.0) Tv=10.0;
            if(Tw<30.0) Tw=30.0;

            float ux, uy, uz, rw;
            
            if(d_dt/Tu < 0.5) p.up = (1.0-d_dt/Tu)*p.up + curand_normal_double(&ss)*usig*sqrt(2.0*d_dt/Tu);
            else p.up = exp(-d_dt/Tu)*p.up + curand_normal_double(&ss)*usig*sqrt(1.0-exp(-d_dt/Tu)*exp(-d_dt/Tu));
                    
            if(d_dt/Tv < 0.5) p.vp = (1.0-d_dt/Tv)*p.vp + curand_normal_double(&ss)*vsig*sqrt(2.0*d_dt/Tv);
            else p.vp = exp(-d_dt/Tv)*p.vp + curand_normal_double(&ss)*vsig*sqrt(1.0-exp(-d_dt/Tv)*exp(-d_dt/Tv));    
        
            if(TURB_SWITCH){}
            else{
                rw = exp(-d_dt/Tw);
                float old_wp = p.wp;
                p.wp = (rw*p.wp + curand_normal_double(&ss)*sqrt(1.0-rw*rw)*wsig + Tw*(1.0-rw)*(dsw2+drho/rho*wsig*wsig))*p.dir;
                
                if (idx == 0) {
                    static int wp_debug_count = 0;
                    if (wp_debug_count < 3) {
                        printf("[WP_CALC] Particle 0: Tw=%.6f, rw=%.6f, old_wp=%.6f, wsig=%.6f, dsw2=%.6f, drho=%.6f, rho=%.6f, p.dir=%d, new_wp=%.6f (NaN=%d)\n", 
                               Tw, rw, old_wp, wsig, dsw2, drho, rho, p.dir, p.wp, isnan(p.wp));
                        wp_debug_count++;
                    }
                }
            }
            

            // Debug disabled for performance
            
            if (p.wp*d_dt < -p.z){
                p.dir = -1;
                float old_z = p.z;
                p.z = -p.z - p.wp*d_dt;
                if (idx == 0) {
                    static int reflect_debug1 = 0;
                    if (reflect_debug1 < 3) {
                        printf("[Z_REFLECT1] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                               old_z, p.wp, d_dt, p.z, isnan(p.z));
                        reflect_debug1++;
                    }
                }
            }
            else if (p.wp*d_dt > (hmix-p.z)){
                p.dir = -1;
                float old_z = p.z;
                p.z = -p.z - p.wp*d_dt + 2.*hmix;
                if (idx == 0) {
                    static int reflect_debug2 = 0;
                    if (reflect_debug2 < 3) {
                        printf("[Z_REFLECT2] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, hmix=%.6f, new_z=%.6f (NaN=%d)\n", 
                               old_z, p.wp, d_dt, hmix, p.z, isnan(p.z));
                        reflect_debug2++;
                    }
                }
            }
            else{
                p.dir = 1;
                p.z = p.z + p.wp*d_dt;
                if (idx == 0) {
                    static int reflect_debug3 = 0;
                    if (reflect_debug3 < 3) {
                        printf("[Z_NORMAL] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                               p.z - p.wp*d_dt, p.wp, d_dt, p.z, isnan(p.z));
                        reflect_debug3++;
                    }
                }
            }



            //p.z += p.wp*d_dt;

            dx += xwind*d_dt;
            dy += ywind*d_dt;
            dxt += p.up*d_dt;
            dyt += p.vp*d_dt;
            float old_z_zwind = p.z;
            p.z += zwind*d_dt;
            
            // Debug first particle z update for NaN tracking
            if (idx == 0) {
                static int z_debug_count = 0;
                if (z_debug_count < 3) {
                    printf("[Z_UPDATE1] Particle 0: old_z=%.6f, zwind=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                           old_z_zwind, zwind, d_dt, p.z, isnan(p.z));
                    z_debug_count++;
                }
            }

        }
        else{

            float ux, uy, uz;

            
            // if(p.z < trop){
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }
            // else if(p.z < trop+1000.0){
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }
            // else{
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }

            ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            uz = 0.0;

            // if(p.z < trop){
            //     ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            //     uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            //     uz = 0.0;
            // }
            // else if(p.z < trop+1000.0){
            //     ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt*(1-(p.z-trop)/1000.0));
            //     uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt*(1-(p.z-trop)/1000.0));
            //     uz = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.*d_strat/d_dt*(p.z-trop)/1000.0)+d_strat/1000.0;
            // }
            // else{
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.*d_strat/d_dt);
            // }
            

            dx += (xwind+ux)*d_dt;
            dy += (ywind+uy)*d_dt;
            float old_z_strat = p.z;
            p.z += (zwind+uz)*d_dt;
            
            // Debug second particle z update for NaN tracking
            if (idx == 0) {
                static int z_debug_count2 = 0;
                if (z_debug_count2 < 3) {
                    printf("[Z_UPDATE2] Particle 0: old_z=%.6f, zwind=%.6f, uz=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                           old_z_strat, zwind, uz, d_dt, p.z, isnan(p.z));
                    z_debug_count2++;
                }
            }
            
            if(p.z<0.0) {
                float old_z_neg = p.z;
                p.z=-p.z;
                if (idx == 0) {
                    static int z_debug_count3 = 0;
                    if (z_debug_count3 < 3) {
                        printf("[Z_UPDATE3] Particle 0: negative z correction: %.6f -> %.6f (NaN=%d)\n", 
                               old_z_neg, p.z, isnan(p.z));
                        z_debug_count3++;
                    }
                }
            }

        }

        float r = exp(-2.0*d_dt/static_cast<float>(time_interval));
        float rs = sqrt(1.0-r*r);

        if(p.z<0.0) {
            float old_z_final_neg = p.z;
            p.z=-p.z;
        }

        
        float wind = sqrt(xwind*xwind+ywind*ywind);

        dx += xwind/wind*dxt-ywind/wind*dyt;
        dy += ywind/wind*dxt+xwind/wind*dyt;

        //printf("s1= %f, s2= %f\n", xwind/wind*dxt-ywind/wind*dyt, ywind/wind*dxt+xwind/wind*dyt);

        s1 = 180.0/(0.5*r_earth*PI);// dxconst, dyconst
        s2 = s1/cos((p.y*0.5-90.0)*PI180);// cosfact

        //printf("dx= %f, dy= %f, s1= %f, s2= %f\n", dx, dy, s1, s2);
        //printf("dx= %f, dy= %f\n", dx*s2, dy*s1);
        p.x += dx*s2; //!!
        p.y += dy*s1; //!!
        

        if(p.z > d_flex_hgt[dimZ_GFS-1]) {
            float old_z_clamp = p.z;
            p.z = d_flex_hgt[dimZ_GFS-1]*0.999999;
        }

        float prob = 0.0;
        float decfact = 1.0;
        float prob_dry = 0.0f;

        if (d_drydep && p.z < 2.0f * _href) {
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP enabled: z=%.2f, href=%.2f, vdep=%.6f\n", p.z, _href, vdep);
            // }
            float arg = -vdep * d_dt / (2.0f * _href);
            prob_dry = clamp01(1.0f - __expf(arg));
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP calculation: arg=%.6f, exp(arg)=%.6f, prob_dry=%.6f\n", arg, __expf(arg), prob_dry);
            // }
        } 
        //else if (idx == 0 && tstep <= 3) {
        //     printf("[GPU] DRYDEP disabled or z too high: d_drydep=%d, z=%.2f\n", d_drydep, p.z);
        // }

        float clouds_v, clouds_h;

        if(t0<=0.5) {
            clouds_v = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].CLDS;
            clouds_h = device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].CLDH;
        }
        else{
            clouds_v = device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].CLDS;
            clouds_h = device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].CLDH;
        }

            float wet_removal = 0.0f;

            if (d_wetdep && (lsp >= 0.01f || convp >= 0.01f) && clouds_v > 1.0f) {
                // if (idx == 0 && tstep <= 3) {
                //     printf("[GPU] WETDEP enabled: lsp=%.3f, convp=%.3f, clouds=%.1f\n", lsp, convp, clouds_v);
                // }
                const float lfr[5] = {0.5f, 0.65f, 0.8f, 0.9f, 0.95f};
                const float cfr[5] = {0.4f, 0.55f, 0.7f, 0.8f, 0.9f};

                int weti = (lsp > 20.0f) ? 5 : (lsp > 8.0f) ? 4 : (lsp > 3.0f) ? 3 : (lsp > 1.0f) ? 2 : 1;
                int wetj = (convp > 20.0f) ? 5 : (convp > 8.0f) ? 4 : (convp > 3.0f) ? 3 : (convp > 1.0f) ? 2 : 1;

                float grfraction = 0.05f;
                if (lsp + convp > 0.0f) {
                    grfraction = fmaxf(0.05f, cc * (lsp * lfr[weti - 1] + convp * cfr[wetj - 1]) / (lsp + convp));
                }

                float prec = (lsp + convp) / grfraction;

                // 스캐빈징
                float wetscav = 0.0f;
                const float weta = 9.99999975e-5f;
                const float wetb = 0.800000012f;
                const float henry = p.drydep_vel;

                if (weta > 0.0f) {
                    if (clouds_v >= 4.0f) {
                        wetscav = weta * powf(prec, wetb);
                    } else {
                        float act_temp = (t0 <= 0.5f)
                            ? device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].TT
                            : device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].TT;
                        float cl = 2.0e-7f * powf(prec, 0.36f);
                        float S_i = (p.radi > 1.0e-10f)
                            ? (0.9f / cl)
                            : 1.0f / ((1.0f - cl) / (henry * (_rair / 3500.0f) * act_temp) + cl);
                        wetscav = S_i * prec / 3.6e6f / fmaxf(1.0f, clouds_h);
                    }
                }

                wet_removal = clamp01((1.0f - __expf(-wetscav * d_dt)) * grfraction);
            } 
            //else if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] WETDEP disabled or no precipitation: d_wetdep=%d, lsp=%.3f, convp=%.3f\n", d_wetdep, lsp, convp);
            // }

            if (d_raddecay) {
                // if (idx == 0 && tstep <= 5) {  // Only first particle, first few timesteps
                //     printf("[GPU] RADDECAY enabled: applying T matrix\n");
                // }
                //apply_T_once_rowmajor_60(T_const, p.concentrations);
                cram_decay_calculation(T_const, p.concentrations);
            } 
            // else if (idx == 0 && tstep <= 5) {
            //     printf("[GPU] RADDECAY disabled: skipping T matrix\n");
            // }


            if (d_wetdep && wet_removal > 0.0f) {
                #pragma unroll
                for (int i = 0; i < N_NUCLIDES; ++i) {
                    float c = p.concentrations[i];
                    if (c > 0.0f) p.concentrations[i] = c * (1.0f - wet_removal);
                }
            }


        if (d_drydep && prob_dry > 0.0f) {
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP applying: prob_dry=%.6f\n", prob_dry);
            // }
            
            #pragma unroll
            for (int i = 0; i < N_NUCLIDES; ++i) {
                float c = p.concentrations[i];
                if (c > 0.0f) p.concentrations[i] = c * (1.0f - prob_dry);
            }
            
        } 
        //else if (d_drydep && idx == 0 && tstep <= 3) {
        //     printf("[GPU] DRYDEP not applying: prob_dry=%.6f\n", prob_dry);
        // }


    float total = 0.0f;
    #pragma unroll
    for (int i = 0; i < N_NUCLIDES; ++i) {
        float c = p.concentrations[i];
        c = isfinite(c) ? c : 0.0f;
        c = fminf(c, 1e20f);
        // ALLOW NEGATIVE CONCENTRATIONS for EKI algorithm
        // c = fmaxf(c, 0.0f);  // REMOVED: Don't clamp to zero
        p.concentrations[i] = c;
        total += c;
    }
    // ALLOW NEGATIVE TOTAL for EKI algorithm
    // p.conc = fminf(fmaxf(total, 0.0f), 1e20f);  // REMOVED: Don't clamp to zero
    p.conc = isfinite(total) ? fminf(total, 1e20f) : 0.0f;
    

        // Safety checks for wind components
        p.u_wind = isnan(xwind) ? 0.0f : xwind;
        p.v_wind = isnan(ywind) ? 0.0f : ywind;
        p.w_wind = isnan(zwind) ? 0.0f : zwind;

        // Final debug only for critical check
        if (idx == 0) {
            static int final_debug_count = 0;
            if (final_debug_count < 5) {
                printf("[FINAL] Particle 0: z=%.3f (NaN=%d)\n", p.z, isnan(p.z));
                final_debug_count++;
            }
        }

        // DEBUG: Check concentrations for first 3 particles on EVERY kernel execution
        if (idx < 3) {
            printf("[GPU_ENS_INIT] P%d (ens=%d, timeidx=%d, flag=%d): conc=%.3e, conc[0]=%.3e, sum=%.3e\n",
                   idx, p.ensemble_id, p.timeidx, p.flag, p.conc, p.concentrations[0], total);
        }

}

// ================== EKI OBSERVATION SYSTEM ==================

// EKI observation kernel - computes receptor measurements based on particle positions
__global__ void compute_eki_receptor_dose(
    const LDM::LDMpart* particles,
    const float* receptor_lats, const float* receptor_lons,
    float receptor_capture_radius,
    float* receptor_dose,  // Now 2D: [num_receptors * num_timesteps]
    int* receptor_particle_count,  // Now 2D: [num_receptors * num_timesteps]
    int num_receptors,
    int num_timesteps,
    int time_idx,  // NEW: which timestep slot to accumulate into
    float DCF = 1.0f) {

    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= d_nop) return;

    LDM::LDMpart particle = particles[idx];
    if (particle.flag == 0) return; // Skip inactive particles

    // Convert grid coordinates to lat/lon
    float lat = -90.0f + particle.y * 0.5f;
    float lon = -179.0f + particle.x * 0.5f;

    // Skip particles outside reasonable altitude range
    if (particle.z > 5000.0f) return;

    // Check each receptor
    for (int r = 0; r < num_receptors; ++r) {
        float receptor_lat = receptor_lats[r];
        float receptor_lon = receptor_lons[r];

        // Check if particle is within receptor capture radius
        float lat_diff = fabs(lat - receptor_lat);
        float lon_diff = fabs(lon - receptor_lon);

        if (lat_diff <= receptor_capture_radius && lon_diff <= receptor_capture_radius) {
            // Calculate dose contribution from this particle
            float dose_increment = particle.conc * DCF * d_time_end / static_cast<float>(d_nop);

            // Calculate 2D index: [timestep][receptor] - MATCH REFERENCE CODE
            // Reference: gamma_dose_idx = ens * (TIME * RECEPT) + r + time_idx * RECEPT
            // Single mode: just time_idx * num_receptors + r
            int dose_idx = time_idx * num_receptors + r;

            // Atomically add to the correct time_idx slot
            atomicAdd(&receptor_dose[dose_idx], dose_increment);
            atomicAdd(&receptor_particle_count[dose_idx], 1);
        }
    }
}

// EKI ensemble mode observation kernel - computes receptor measurements for all ensemble members
__global__ void compute_eki_receptor_dose_ensemble(
    const LDM::LDMpart* particles,
    const float* receptor_lats, const float* receptor_lons,
    float receptor_capture_radius,
    float* ensemble_dose,  // [num_ensembles × num_receptors × num_timesteps]
    int* ensemble_particle_count,  // [num_ensembles × num_receptors × num_timesteps]
    int num_ensembles,
    int num_receptors,
    int num_timesteps,
    int time_idx,  // NEW: which timestep slot to accumulate into (same as single mode)
    int total_particles,
    float DCF = 1.0f) {

    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= total_particles) return;

    LDM::LDMpart particle = particles[idx];
    if (particle.flag == 0) return; // Skip inactive particles

    // Get ensemble ID from particle
    int ens_id = particle.ensemble_id;

    // Convert grid coordinates to lat/lon
    float lat = -90.0f + particle.y * 0.5f;
    float lon = -179.0f + particle.x * 0.5f;

    // Skip particles outside reasonable altitude range
    if (particle.z > 5000.0f) return;

    // Check each receptor
    for (int r = 0; r < num_receptors; ++r) {
        float receptor_lat = receptor_lats[r];
        float receptor_lon = receptor_lons[r];

        // Check if particle is within receptor capture radius
        float lat_diff = fabs(lat - receptor_lat);
        float lon_diff = fabs(lon - receptor_lon);

        if (lat_diff <= receptor_capture_radius && lon_diff <= receptor_capture_radius) {
            // Calculate dose contribution from this particle
            float dose_increment = particle.conc * DCF * d_time_end / static_cast<float>(d_nop);

            // Calculate output index: [ensemble][timestep][receptor] - MATCH REFERENCE CODE
            // Reference: gamma_dose_idx = ens * (TIME * RECEPT) + r + time_idx * RECEPT
            int output_idx = ens_id * (num_timesteps * num_receptors) +
                           time_idx * num_receptors +
                           r;

            // Atomically add to the correct time_idx slot for this ensemble
            atomicAdd(&ensemble_dose[output_idx], dose_increment);
            atomicAdd(&ensemble_particle_count[output_idx], 1);
        }
    }
}

__global__ void move_part_by_wind_mpi_dump(
    LDM::LDMpart* d_part, float t0, int rank, float* d_dryDep, float* d_wetDep, int mesh_nx, int mesh_ny,
    FlexUnis* device_meteorological_flex_unis0,
    FlexPres* device_meteorological_flex_pres0,
    FlexUnis* device_meteorological_flex_unis1,
    FlexPres* device_meteorological_flex_pres1){

        int idx = blockIdx.x * blockDim.x + threadIdx.x;
        if(idx >= d_nop) return;
        //if(idx != 0) return;  // Process all particles

        // Debug output disabled for performance

        LDM::LDMpart& p = d_part[idx];
        if(!p.flag) {
            return;
        }
        
        // Debug disabled for performance

        // Direct use of T_const instead of shared memory copy

        unsigned long long seed = static_cast<unsigned long long>(t0 * ULLONG_MAX);  // Time-dependent seed like CRAM
        curandState ss;
        curand_init(seed, idx, 0, &ss);


        int xidx, yidx;
        if(p.x*0.5 -179.0 >= 180.0) {
            xidx = 1;
            p.flag=false;
        }
        else xidx = int(p.x);
        yidx = int(p.y);

        int zidx = 0;
        int index;

        float fdump = 0;

        float hmix = 0;
        for(int i=0; i<2; i++){
            for(int j=0; j<2; j++){
                index = (xidx+i) * dimY_GFS + (yidx+j);
                hmix = max(hmix, device_meteorological_flex_unis0[index].HMIX);
                hmix = max(hmix, device_meteorological_flex_unis1[index].HMIX);
            }
        }

        // Debug disabled for performance

        float zeta = p.z/hmix;
        
        for(int i=0; i<dimZ_GFS; i++){
            if(d_flex_hgt[i] > p.z){
                zidx = i-1;  // Fixed: use lower level index like CRAM
                break;
            }
        }
        if(zidx < 0) zidx = 0;  // Ensure non-negative index

        float x0 = p.x-xidx;
        float y0 = p.y-yidx;
        
        // CRITICAL FIX: 높이 차이가 0에 가까우면 안전한 값으로 설정
        float height_diff = d_flex_hgt[zidx+1] - d_flex_hgt[zidx];
        float z0;
        if (abs(height_diff) < 1e-6f) {
            z0 = 0.0f; // 높이 차이가 거의 없으면 하위 레벨 사용
        } else {
            z0 = (p.z - d_flex_hgt[zidx]) / height_diff;
        }
        
        float x1 = 1-x0;
        float y1 = 1-y0;
        float z1 = 1-z0;
        float t1 = 1-t0;
        
        // Debug disabled for performance

        float ustr = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].USTR
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].USTR
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].USTR
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].USTR
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].USTR
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].USTR
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].USTR
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].USTR;

        float wstr = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].WSTR
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].WSTR
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].WSTR
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].WSTR
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].WSTR
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].WSTR
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].WSTR
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].WSTR;

        float obkl = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].OBKL
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].OBKL
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].OBKL
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].OBKL
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].OBKL
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].OBKL
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].OBKL
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].OBKL;

        obkl = 1/obkl;

        float vdep = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].VDEP
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].VDEP
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].VDEP
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].VDEP
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].VDEP
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].VDEP
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].VDEP
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].VDEP;

        float lsp = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].LPREC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].LPREC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].LPREC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].LPREC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].LPREC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].LPREC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].LPREC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].LPREC;

        float convp = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].CPREC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].CPREC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].CPREC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].CPREC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].CPREC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].CPREC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].CPREC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].CPREC;

        float cc = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].TCC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].TCC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].TCC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].TCC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].TCC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].TCC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].TCC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].TCC;


        // Debug: Check individual DRHO values before interpolation
        float drho_000 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO;
        float drho_100 = device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO;
        
        if (idx == 0 && isnan(drho_000)) {
            printf("[DRHO_DEBUG] DRHO_000 is NaN at indices [%d,%d,%d,%d]\n", xidx, yidx, zidx, 0);
        }
        if (idx == 0 && isnan(drho_100)) {
            printf("[DRHO_DEBUG] DRHO_100 is NaN at indices [%d,%d,%d,%d]\n", xidx+1, yidx, zidx, 0);
        }
        
        float drho_raw = x1*y1*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x0*y1*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x1*y0*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x0*y0*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x1*y1*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y1*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y0*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y0*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y1*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x0*y1*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x1*y0*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x0*y0*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x1*y1*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y1*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y0*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y0*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO;
        
        // Fix NaN issue: replace NaN with 0
        float drho = isnan(drho_raw) ? 0.0f : drho_raw;

        float rho = x1*y1*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x0*y1*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x1*y0*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x0*y0*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x1*y1*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y1*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y0*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y0*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y1*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x0*y1*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x1*y0*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x0*y0*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x1*y1*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y1*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y0*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y0*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO;

        // Optimize memory access by caching meteorological data points
        FlexPres met_p0[8], met_p1[8];
        
        // Cache meteorological data points with boundary checks
        // Ensure array indices are within bounds to prevent memory access violations
        int safe_xidx = min(xidx, dimX_GFS - 2);    // Ensure xidx+1 is valid
        int safe_yidx = min(yidx, dimY_GFS - 2);    // Ensure yidx+1 is valid
        int safe_zidx = min(zidx, dimZ_GFS - 2);    // Ensure zidx+1 is valid
        
        met_p0[0] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p0[1] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p0[2] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p0[3] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p0[4] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p0[5] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p0[6] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        met_p0[7] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        
        met_p1[0] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p1[1] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p1[2] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p1[3] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p1[4] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p1[5] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p1[6] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        met_p1[7] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        
        // Debug disabled for performance

        float temp = x1*y1*z1*t1*met_p0[0].TT + x0*y1*z1*t1*met_p0[1].TT + x1*y0*z1*t1*met_p0[2].TT + x0*y0*z1*t1*met_p0[3].TT
                    +x1*y1*z0*t1*met_p0[4].TT + x0*y1*z0*t1*met_p0[5].TT + x1*y0*z0*t1*met_p0[6].TT + x0*y0*z0*t1*met_p0[7].TT
                    +x1*y1*z1*t0*met_p1[0].TT + x0*y1*z1*t0*met_p1[1].TT + x1*y0*z1*t0*met_p1[2].TT + x0*y0*z1*t0*met_p1[3].TT
                    +x1*y1*z0*t0*met_p1[4].TT + x0*y1*z0*t0*met_p1[5].TT + x1*y0*z0*t0*met_p1[6].TT + x0*y0*z0*t0*met_p1[7].TT;

        float xwind = 1.0;

        float ywind = 0.0;

        float zwind = 0.0;

        // Debug wind calculation for NaN tracking
        if (idx == 0) {
            static int wind_debug_count = 0;
            if (wind_debug_count < 3) {
                printf("[WIND_CALC] Particle 0: xwind=%.6f, ywind=%.6f, zwind=%.6f (NaN: x=%d, y=%d, z=%d)\n", 
                       xwind, ywind, zwind, isnan(xwind), isnan(ywind), isnan(zwind));
                wind_debug_count++;
            }
        }

        // Critical debug: Only check for first timestep NaN issue
        if (idx == 0) {
            static int debug_count = 0;
            if (debug_count < 3) {
                printf("[CRITICAL] Particle 0: p.x=%.3f, p.y=%.3f, p.z=%.3f -> x1=%.3f, y1=%.3f, z1=%.3f -> xwind=%.3f\n", 
                       p.x, p.y, p.z, x1, y1, z1, xwind);
                printf("[DEBUG_Z_AFTER_CRITICAL] Particle 0: p.z=%.6f (NaN=%d)\n", p.z, isnan(p.z));
                debug_count++;
            }
        }



        float usig, vsig, wsig, dsw2;
        float uusig = 0, vvsig = 0, wwsig = 0;
        float Tu, Tv, Tw;
        float s1, s2;

        float dx = 0, dy = 0;
        float dxt = 0, dyt = 0;

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU;

        uusig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU;

        uusig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV;

        vvsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV;

        vvsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW;

        wwsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW;

        wwsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        // p.radi = 6.0e-1;
        // p.prho = 2500.0;

        float vis = Dynamic_viscosity(temp)/rho;
        float Re = p.radi/1.0e6*fabsf(d_vsetaver)/vis;
        float settold = d_vsetaver;
        float settling;
        float c_d;

        if(p.radi > 1.0e-10){
            for(int i=0; i<20; i++){
                if(Re<1.917) c_d = 24.0/Re;
                else if(Re<500.0) c_d = 18.5/pow(Re, 0.6);
                else c_d = 0.44;
    
                settling = -1.0*sqrt(4.0*_ga*p.radi/1.0e6*p.prho*d_cunningham/(3.0*c_d*rho));

                if(fabsf((settling-settold)/settling)<0.01) break;
    
                Re = p.radi/1.0e6*fabsf(settling)/vis;
                settold = settling;
            }
            zwind += settling;
        }


        p.w_wind = zwind;

        if(zeta <= 1.0) {

            if(hmix/abs(obkl) < 1.0){ // Neutral condition
                if(ustr<1.0e-4) ustr=1.0e-4;
                usig = 2.0*ustr*exp(-3.0e-4*p.z/ustr);
                if(usig<1.0e-5) usig=1.0e-5;
                vsig = 1.3*ustr*exp(-2.0e-4*p.z/ustr);
                if(vsig<1.0e-5) vsig=1.0e-5;
                wsig=vsig;

                dsw2 = -6.76e-4*ustr*exp(-4.0e-4*p.z/ustr);

                Tu=0.5*p.z/wsig/(1.0+1.5e-3*p.z/ustr);
                Tv=Tu;
                Tw=Tu;

            }

            else if(obkl < 0.0){ // Unstable condition
                usig = ustr*pow(12-0.5*hmix/obkl,1.0/3.0);
                if(usig<1.0e-6) usig=1.0e-6;
                vsig = usig;

                
                if(zeta < 0.03){
                    wsig = 0.9600*wstr*pow(3*zeta-obkl/hmix,1.0/3.0);
                    dsw2 = 1.8432*wstr*wstr/hmix*pow(3*zeta-obkl/hmix,-1.0/3.0);
                }
                else if(zeta < 0.40){
                    s1 = 0.9600*pow(3*zeta-obkl/hmix,1.0/3.0);
                    s2 = 0.7630*pow(zeta,0.175);
                    if(s1 < s2){
                        wsig = wstr*s1;
                        dsw2 = 1.8432*wstr*wstr/hmix*pow(3*zeta-obkl/hmix,-1.0/3.0);
                    }
                    else{
                        wsig = wstr*s2;
                        dsw2 = 0.203759*wstr*wstr/hmix*pow(zeta,-0.65);
                    }
                }
                else if(zeta < 0.96){
                    wsig = 0.722*wstr*pow(1-zeta,0.207);
                    dsw2 = -0.215812*wstr*wstr/hmix*pow(1-zeta,-0.586);
                }
                else if(zeta < 1.00){
                    wsig = 0.37*wstr;
                    dsw2 = 0.00;
                }

                if(wsig<1.0e-6) wsig=1.0e-6;

                Tu = 0.15*hmix/usig;
                Tv = Tu;

                if(p.z < abs(obkl)){
                    Tw = 0.1*p.z/(wsig*(0.55-0.38*abs(p.z/obkl)));
                } 
                else if(zeta < 0.1){
                    Tw = 0.59*p.z/wsig;
                }
                else{
                    Tw = 0.15*hmix/wsig*(1.0-exp(-5*zeta));
                }
            }

            else{ // Stable condition

                usig = 2.0*ustr*(1.0-zeta);
                vsig = 1.3*ustr*(1.0-zeta);
                if(usig<1.0e-6) usig=1.0e-6;
                if(vsig<1.0e-6) vsig=1.0e-6;
                wsig = vsig;

                dsw2 = 3.38*ustr*ustr*(zeta-1.0)/hmix;

                Tu = 0.15*hmix/usig*sqrt(zeta);
                Tv = 0.467*Tu;
                Tw = 0.1*hmix/wsig*pow(zeta,0.8);

            }

            if(Tu<10.0) Tu=10.0;
            if(Tv<10.0) Tv=10.0;
            if(Tw<30.0) Tw=30.0;

            float ux, uy, uz, rw;
            
            if(d_dt/Tu < 0.5) p.up = (1.0-d_dt/Tu)*p.up + curand_normal_double(&ss)*usig*sqrt(2.0*d_dt/Tu);
            else p.up = exp(-d_dt/Tu)*p.up + curand_normal_double(&ss)*usig*sqrt(1.0-exp(-d_dt/Tu)*exp(-d_dt/Tu));
                    
            if(d_dt/Tv < 0.5) p.vp = (1.0-d_dt/Tv)*p.vp + curand_normal_double(&ss)*vsig*sqrt(2.0*d_dt/Tv);
            else p.vp = exp(-d_dt/Tv)*p.vp + curand_normal_double(&ss)*vsig*sqrt(1.0-exp(-d_dt/Tv)*exp(-d_dt/Tv));    
        
            if(TURB_SWITCH){}
            else{
                rw = exp(-d_dt/Tw);
                float old_wp = p.wp;
                p.wp = (rw*p.wp + curand_normal_double(&ss)*sqrt(1.0-rw*rw)*wsig + Tw*(1.0-rw)*(dsw2+drho/rho*wsig*wsig))*p.dir;
                
                if (idx == 0) {
                    static int wp_debug_count = 0;
                    if (wp_debug_count < 3) {
                        printf("[WP_CALC] Particle 0: Tw=%.6f, rw=%.6f, old_wp=%.6f, wsig=%.6f, dsw2=%.6f, drho=%.6f, rho=%.6f, p.dir=%d, new_wp=%.6f (NaN=%d)\n", 
                               Tw, rw, old_wp, wsig, dsw2, drho, rho, p.dir, p.wp, isnan(p.wp));
                        wp_debug_count++;
                    }
                }
            }
            

            // Debug disabled for performance
            
            // if (p.wp*d_dt < -p.z){
            //     p.dir = -1;
            //     float old_z = p.z;
            //     p.z = -p.z - p.wp*d_dt;
            //     if (idx == 0) {
            //         static int reflect_debug1 = 0;
            //         if (reflect_debug1 < 3) {
            //             printf("[Z_REFLECT1] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
            //                    old_z, p.wp, d_dt, p.z, isnan(p.z));
            //             reflect_debug1++;
            //         }
            //     }
            // }
            // else if (p.wp*d_dt > (hmix-p.z)){
            //     p.dir = -1;
            //     float old_z = p.z;
            //     p.z = -p.z - p.wp*d_dt + 2.*hmix;
            //     if (idx == 0) {
            //         static int reflect_debug2 = 0;
            //         if (reflect_debug2 < 3) {
            //             printf("[Z_REFLECT2] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, hmix=%.6f, new_z=%.6f (NaN=%d)\n", 
            //                    old_z, p.wp, d_dt, hmix, p.z, isnan(p.z));
            //             reflect_debug2++;
            //         }
            //     }
            // }
            // else{
            //     p.dir = 1;
            //     p.z = p.z + p.wp*d_dt;
            //     if (idx == 0) {
            //         static int reflect_debug3 = 0;
            //         if (reflect_debug3 < 3) {
            //             printf("[Z_NORMAL] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
            //                    p.z - p.wp*d_dt, p.wp, d_dt, p.z, isnan(p.z));
            //             reflect_debug3++;
            //         }
            //     }
            // }



            //p.z += p.wp*d_dt;

            dx += xwind*d_dt;
            dy += ywind*d_dt;
            // dxt += p.up*d_dt;
            // dyt += p.vp*d_dt;
            float old_z_zwind = p.z;
            // p.z += zwind*d_dt;
            
            // Debug first particle z update for NaN tracking
            if (idx == 0) {
                static int z_debug_count = 0;
                if (z_debug_count < 3) {
                    printf("[Z_UPDATE1] Particle 0: old_z=%.6f, zwind=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                           old_z_zwind, zwind, d_dt, p.z, isnan(p.z));
                    z_debug_count++;
                }
            }

        }
        else{

            float ux, uy, uz;

            
            // if(p.z < trop){
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }
            // else if(p.z < trop+1000.0){
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }
            // else{
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }

            ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            uz = 0.0;

            // if(p.z < trop){
            //     ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            //     uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            //     uz = 0.0;
            // }
            // else if(p.z < trop+1000.0){
            //     ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt*(1-(p.z-trop)/1000.0));
            //     uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt*(1-(p.z-trop)/1000.0));
            //     uz = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.*d_strat/d_dt*(p.z-trop)/1000.0)+d_strat/1000.0;
            // }
            // else{
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.*d_strat/d_dt);
            // }
            

            dx += (xwind+ux)*d_dt;
            dy += (ywind+uy)*d_dt;
            float old_z_strat = p.z;
            p.z += (zwind+uz)*d_dt;
            
            // Debug second particle z update for NaN tracking
            if (idx == 0) {
                static int z_debug_count2 = 0;
                if (z_debug_count2 < 3) {
                    printf("[Z_UPDATE2] Particle 0: old_z=%.6f, zwind=%.6f, uz=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                           old_z_strat, zwind, uz, d_dt, p.z, isnan(p.z));
                    z_debug_count2++;
                }
            }
            
            if(p.z<0.0) {
                float old_z_neg = p.z;
                p.z=-p.z;
                if (idx == 0) {
                    static int z_debug_count3 = 0;
                    if (z_debug_count3 < 3) {
                        printf("[Z_UPDATE3] Particle 0: negative z correction: %.6f -> %.6f (NaN=%d)\n", 
                               old_z_neg, p.z, isnan(p.z));
                        z_debug_count3++;
                    }
                }
            }

        }

        float r = exp(-2.0*d_dt/static_cast<float>(time_interval));
        float rs = sqrt(1.0-r*r);

        if(p.z<0.0) {
            float old_z_final_neg = p.z;
            p.z=-p.z;
        }

        
        float wind = sqrt(xwind*xwind+ywind*ywind);

        dx += xwind/wind*dxt-ywind/wind*dyt;
        dy += ywind/wind*dxt+xwind/wind*dyt;

        //printf("s1= %f, s2= %f\n", xwind/wind*dxt-ywind/wind*dyt, ywind/wind*dxt+xwind/wind*dyt);

        s1 = 180.0/(0.5*r_earth*PI);// dxconst, dyconst
        s2 = s1/cos((p.y*0.5-90.0)*PI180);// cosfact

        //printf("dx= %f, dy= %f, s1= %f, s2= %f\n", dx, dy, s1, s2);
        //printf("dx= %f, dy= %f\n", dx*s2, dy*s1);
        p.x += dx*s2; //!!
        p.y += dy*s1; //!!
        

        if(p.z > d_flex_hgt[dimZ_GFS-1]) {
            float old_z_clamp = p.z;
            p.z = d_flex_hgt[dimZ_GFS-1]*0.999999;
        }

        float prob = 0.0;
        float decfact = 1.0;
        float prob_dry = 0.0f;

        if (d_drydep && p.z < 2.0f * _href) {
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP enabled: z=%.2f, href=%.2f, vdep=%.6f\n", p.z, _href, vdep);
            // }
            float arg = -vdep * d_dt / (2.0f * _href);
            prob_dry = clamp01(1.0f - __expf(arg));
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP calculation: arg=%.6f, exp(arg)=%.6f, prob_dry=%.6f\n", arg, __expf(arg), prob_dry);
            // }
        } 
        //else if (idx == 0 && tstep <= 3) {
        //     printf("[GPU] DRYDEP disabled or z too high: d_drydep=%d, z=%.2f\n", d_drydep, p.z);
        // }

        float clouds_v, clouds_h;

        if(t0<=0.5) {
            clouds_v = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].CLDS;
            clouds_h = device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].CLDH;
        }
        else{
            clouds_v = device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].CLDS;
            clouds_h = device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].CLDH;
        }

            float wet_removal = 0.0f;

            if (d_wetdep && (lsp >= 0.01f || convp >= 0.01f) && clouds_v > 1.0f) {
                // if (idx == 0 && tstep <= 3) {
                //     printf("[GPU] WETDEP enabled: lsp=%.3f, convp=%.3f, clouds=%.1f\n", lsp, convp, clouds_v);
                // }
                const float lfr[5] = {0.5f, 0.65f, 0.8f, 0.9f, 0.95f};
                const float cfr[5] = {0.4f, 0.55f, 0.7f, 0.8f, 0.9f};

                int weti = (lsp > 20.0f) ? 5 : (lsp > 8.0f) ? 4 : (lsp > 3.0f) ? 3 : (lsp > 1.0f) ? 2 : 1;
                int wetj = (convp > 20.0f) ? 5 : (convp > 8.0f) ? 4 : (convp > 3.0f) ? 3 : (convp > 1.0f) ? 2 : 1;

                float grfraction = 0.05f;
                if (lsp + convp > 0.0f) {
                    grfraction = fmaxf(0.05f, cc * (lsp * lfr[weti - 1] + convp * cfr[wetj - 1]) / (lsp + convp));
                }

                float prec = (lsp + convp) / grfraction;

                // 스캐빈징
                float wetscav = 0.0f;
                const float weta = 9.99999975e-5f;
                const float wetb = 0.800000012f;
                const float henry = p.drydep_vel;

                if (weta > 0.0f) {
                    if (clouds_v >= 4.0f) {
                        wetscav = weta * powf(prec, wetb);
                    } else {
                        float act_temp = (t0 <= 0.5f)
                            ? device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].TT
                            : device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].TT;
                        float cl = 2.0e-7f * powf(prec, 0.36f);
                        float S_i = (p.radi > 1.0e-10f)
                            ? (0.9f / cl)
                            : 1.0f / ((1.0f - cl) / (henry * (_rair / 3500.0f) * act_temp) + cl);
                        wetscav = S_i * prec / 3.6e6f / fmaxf(1.0f, clouds_h);
                    }
                }

                wet_removal = clamp01((1.0f - __expf(-wetscav * d_dt)) * grfraction);
            } 
            //else if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] WETDEP disabled or no precipitation: d_wetdep=%d, lsp=%.3f, convp=%.3f\n", d_wetdep, lsp, convp);
            // }

            if (d_raddecay) {
                // if (idx == 0 && tstep <= 5) {  // Only first particle, first few timesteps
                //     printf("[GPU] RADDECAY enabled: applying T matrix\n");
                // }
                //apply_T_once_rowmajor_60(T_const, p.concentrations);
                cram_decay_calculation(T_const, p.concentrations);
            } 
            // else if (idx == 0 && tstep <= 5) {
            //     printf("[GPU] RADDECAY disabled: skipping T matrix\n");
            // }


            if (d_wetdep && wet_removal > 0.0f) {
                #pragma unroll
                for (int i = 0; i < N_NUCLIDES; ++i) {
                    float c = p.concentrations[i];
                    if (c > 0.0f) p.concentrations[i] = c * (1.0f - wet_removal);
                }
            }


        if (d_drydep && prob_dry > 0.0f) {
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP applying: prob_dry=%.6f\n", prob_dry);
            // }
            
            #pragma unroll
            for (int i = 0; i < N_NUCLIDES; ++i) {
                float c = p.concentrations[i];
                if (c > 0.0f) p.concentrations[i] = c * (1.0f - prob_dry);
            }
            
        } 
        //else if (d_drydep && idx == 0 && tstep <= 3) {
        //     printf("[GPU] DRYDEP not applying: prob_dry=%.6f\n", prob_dry);
        // }


    float total = 0.0f;
    #pragma unroll
    for (int i = 0; i < N_NUCLIDES; ++i) {
        float c = p.concentrations[i];
        c = isfinite(c) ? c : 0.0f;
        c = fminf(c, 1e20f);
        // ALLOW NEGATIVE CONCENTRATIONS for EKI algorithm
        // c = fmaxf(c, 0.0f);  // REMOVED: Don't clamp to zero
        p.concentrations[i] = c;
        total += c;
    }
    // ALLOW NEGATIVE TOTAL for EKI algorithm
    // p.conc = fminf(fmaxf(total, 0.0f), 1e20f);  // REMOVED: Don't clamp to zero
    p.conc = isfinite(total) ? fminf(total, 1e20f) : 0.0f;
    

        // Safety checks for wind components
        p.u_wind = isnan(xwind) ? 0.0f : xwind;
        p.v_wind = isnan(ywind) ? 0.0f : ywind;
        p.w_wind = isnan(zwind) ? 0.0f : zwind;

        // Final debug only for critical check
        if (idx == 0) {
            static int final_debug_count = 0;
            if (final_debug_count < 5) {
                printf("[FINAL] Particle 0: z=%.3f (NaN=%d)\n", p.z, isnan(p.z));
                final_debug_count++;
            }
        }

}

__global__ void move_part_by_wind_mpi_ens_dump(
    LDM::LDMpart* d_part, float t0, int rank, float* d_dryDep, float* d_wetDep, int mesh_nx, int mesh_ny,
    FlexUnis* device_meteorological_flex_unis0,
    FlexPres* device_meteorological_flex_pres0,
    FlexUnis* device_meteorological_flex_unis1,
    FlexPres* device_meteorological_flex_pres1,
    int total_particles){

        int idx = blockIdx.x * blockDim.x + threadIdx.x;
        if(idx >= total_particles) return;
        //if(idx != 0) return;  // Process all particles

        // Debug output disabled for performance

        LDM::LDMpart& p = d_part[idx];
        if(!p.flag) {
            return;
        }
        
        // Debug disabled for performance

        // Direct use of T_const instead of shared memory copy

        unsigned long long seed = static_cast<unsigned long long>(t0 * ULLONG_MAX);  // Time-dependent seed like CRAM
        curandState ss;
        curand_init(seed, idx, 0, &ss);


        int xidx, yidx;
        if(p.x*0.5 -179.0 >= 180.0) {
            xidx = 1;
            p.flag=false;
        }
        else xidx = int(p.x);
        yidx = int(p.y);

        int zidx = 0;
        int index;

        float fdump = 0;

        float hmix = 0;
        for(int i=0; i<2; i++){
            for(int j=0; j<2; j++){
                index = (xidx+i) * dimY_GFS + (yidx+j);
                hmix = max(hmix, device_meteorological_flex_unis0[index].HMIX);
                hmix = max(hmix, device_meteorological_flex_unis1[index].HMIX);
            }
        }

        // Debug disabled for performance

        float zeta = p.z/hmix;
        
        for(int i=0; i<dimZ_GFS; i++){
            if(d_flex_hgt[i] > p.z){
                zidx = i-1;  // Fixed: use lower level index like CRAM
                break;
            }
        }
        if(zidx < 0) zidx = 0;  // Ensure non-negative index

        float x0 = p.x-xidx;
        float y0 = p.y-yidx;
        
        // CRITICAL FIX: 높이 차이가 0에 가까우면 안전한 값으로 설정
        float height_diff = d_flex_hgt[zidx+1] - d_flex_hgt[zidx];
        float z0;
        if (abs(height_diff) < 1e-6f) {
            z0 = 0.0f; // 높이 차이가 거의 없으면 하위 레벨 사용
        } else {
            z0 = (p.z - d_flex_hgt[zidx]) / height_diff;
        }
        
        float x1 = 1-x0;
        float y1 = 1-y0;
        float z1 = 1-z0;
        float t1 = 1-t0;
        
        // Debug disabled for performance

        float ustr = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].USTR
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].USTR
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].USTR
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].USTR
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].USTR
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].USTR
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].USTR
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].USTR;

        float wstr = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].WSTR
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].WSTR
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].WSTR
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].WSTR
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].WSTR
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].WSTR
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].WSTR
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].WSTR;

        float obkl = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].OBKL
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].OBKL
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].OBKL
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].OBKL
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].OBKL
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].OBKL
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].OBKL
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].OBKL;

        obkl = 1/obkl;

        float vdep = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].VDEP
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].VDEP
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].VDEP
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].VDEP
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].VDEP
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].VDEP
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].VDEP
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].VDEP;

        float lsp = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].LPREC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].LPREC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].LPREC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].LPREC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].LPREC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].LPREC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].LPREC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].LPREC;

        float convp = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].CPREC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].CPREC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].CPREC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].CPREC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].CPREC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].CPREC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].CPREC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].CPREC;

        float cc = x1*y1*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].TCC
                    +x0*y1*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx)].TCC
                    +x1*y0*t1*device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx+1)].TCC
                    +x0*y0*t1*device_meteorological_flex_unis0[(xidx+1) * dimY_GFS + (yidx+1)].TCC
                    +x1*y1*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].TCC
                    +x0*y1*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx)].TCC
                    +x1*y0*t0*device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx+1)].TCC
                    +x0*y0*t0*device_meteorological_flex_unis1[(xidx+1) * dimY_GFS + (yidx+1)].TCC;


        // Debug: Check individual DRHO values before interpolation
        float drho_000 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO;
        float drho_100 = device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO;
        
        if (idx == 0 && isnan(drho_000)) {
            printf("[DRHO_DEBUG] DRHO_000 is NaN at indices [%d,%d,%d,%d]\n", xidx, yidx, zidx, 0);
        }
        if (idx == 0 && isnan(drho_100)) {
            printf("[DRHO_DEBUG] DRHO_100 is NaN at indices [%d,%d,%d,%d]\n", xidx+1, yidx, zidx, 0);
        }
        
        float drho_raw = x1*y1*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x0*y1*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x1*y0*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x0*y0*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x1*y1*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y1*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y0*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y0*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y1*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x0*y1*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].DRHO
                    +x1*y0*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x0*y0*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].DRHO
                    +x1*y1*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y1*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].DRHO
                    +x1*y0*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO
                    +x0*y0*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].DRHO;
        
        // Fix NaN issue: replace NaN with 0
        float drho = isnan(drho_raw) ? 0.0f : drho_raw;

        float rho = x1*y1*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x0*y1*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x1*y0*z1*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x0*y0*z1*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x1*y1*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y1*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y0*z0*t1*device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y0*z0*t1*device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y1*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x0*y1*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].RHO
                   +x1*y0*z1*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x0*y0*z1*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].RHO
                   +x1*y1*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y1*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].RHO
                   +x1*y0*z0*t0*device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO
                   +x0*y0*z0*t0*device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].RHO;

        // Optimize memory access by caching meteorological data points
        FlexPres met_p0[8], met_p1[8];
        
        // Cache meteorological data points with boundary checks
        // Ensure array indices are within bounds to prevent memory access violations
        int safe_xidx = min(xidx, dimX_GFS - 2);    // Ensure xidx+1 is valid
        int safe_yidx = min(yidx, dimY_GFS - 2);    // Ensure yidx+1 is valid
        int safe_zidx = min(zidx, dimZ_GFS - 2);    // Ensure zidx+1 is valid
        
        met_p0[0] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p0[1] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p0[2] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p0[3] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p0[4] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p0[5] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p0[6] = device_meteorological_flex_pres0[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        met_p0[7] = device_meteorological_flex_pres0[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        
        met_p1[0] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p1[1] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx)];
        met_p1[2] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p1[3] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx)];
        met_p1[4] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p1[5] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx) * dimZ_GFS + (safe_zidx+1)];
        met_p1[6] = device_meteorological_flex_pres1[(safe_xidx) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        met_p1[7] = device_meteorological_flex_pres1[(safe_xidx+1) * dimY_GFS * dimZ_GFS + (safe_yidx+1) * dimZ_GFS + (safe_zidx+1)];
        
        // Debug disabled for performance

        float temp = x1*y1*z1*t1*met_p0[0].TT + x0*y1*z1*t1*met_p0[1].TT + x1*y0*z1*t1*met_p0[2].TT + x0*y0*z1*t1*met_p0[3].TT
                    +x1*y1*z0*t1*met_p0[4].TT + x0*y1*z0*t1*met_p0[5].TT + x1*y0*z0*t1*met_p0[6].TT + x0*y0*z0*t1*met_p0[7].TT
                    +x1*y1*z1*t0*met_p1[0].TT + x0*y1*z1*t0*met_p1[1].TT + x1*y0*z1*t0*met_p1[2].TT + x0*y0*z1*t0*met_p1[3].TT
                    +x1*y1*z0*t0*met_p1[4].TT + x0*y1*z0*t0*met_p1[5].TT + x1*y0*z0*t0*met_p1[6].TT + x0*y0*z0*t0*met_p1[7].TT;

        float xwind = 1.0;

        float ywind = 0.0;

        float zwind = 0.0;

        // Debug wind calculation for NaN tracking
        if (idx == 0) {
            static int wind_debug_count = 0;
            if (wind_debug_count < 3) {
                printf("[WIND_CALC] Particle 0: xwind=%.6f, ywind=%.6f, zwind=%.6f (NaN: x=%d, y=%d, z=%d)\n", 
                       xwind, ywind, zwind, isnan(xwind), isnan(ywind), isnan(zwind));
                wind_debug_count++;
            }
        }

        // Critical debug: Only check for first timestep NaN issue
        if (idx == 0) {
            static int debug_count = 0;
            if (debug_count < 3) {
                printf("[CRITICAL] Particle 0: p.x=%.3f, p.y=%.3f, p.z=%.3f -> x1=%.3f, y1=%.3f, z1=%.3f -> xwind=%.3f\n", 
                       p.x, p.y, p.z, x1, y1, z1, xwind);
                printf("[DEBUG_Z_AFTER_CRITICAL] Particle 0: p.z=%.6f (NaN=%d)\n", p.z, isnan(p.z));
                debug_count++;
            }
        }



        float usig, vsig, wsig, dsw2;
        float uusig = 0, vvsig = 0, wwsig = 0;
        float Tu, Tv, Tw;
        float s1, s2;

        float dx = 0, dy = 0;
        float dxt = 0, dyt = 0;

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].UU;

        uusig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].UU;

        uusig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].VV;

        vvsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].VV;

        vvsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx)].WW;

        wwsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);

        s1 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            *device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW;

        s2 = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres0[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW
            +device_meteorological_flex_pres1[(xidx+1) * dimY_GFS * dimZ_GFS + (yidx+1) * dimZ_GFS + (zidx+1)].WW;

        wwsig += 0.5*sqrt((s1-s2*s2/8.0)/7.0);


        // p.radi = 6.0e-1;
        // p.prho = 2500.0;

        float vis = Dynamic_viscosity(temp)/rho;
        float Re = p.radi/1.0e6*fabsf(d_vsetaver)/vis;
        float settold = d_vsetaver;
        float settling;
        float c_d;

        if(p.radi > 1.0e-10){
            for(int i=0; i<20; i++){
                if(Re<1.917) c_d = 24.0/Re;
                else if(Re<500.0) c_d = 18.5/pow(Re, 0.6);
                else c_d = 0.44;
    
                settling = -1.0*sqrt(4.0*_ga*p.radi/1.0e6*p.prho*d_cunningham/(3.0*c_d*rho));

                if(fabsf((settling-settold)/settling)<0.01) break;
    
                Re = p.radi/1.0e6*fabsf(settling)/vis;
                settold = settling;
            }
            zwind += settling;
        }


        p.w_wind = zwind;

        if(zeta <= 1.0) {

            if(hmix/abs(obkl) < 1.0){ // Neutral condition
                if(ustr<1.0e-4) ustr=1.0e-4;
                usig = 2.0*ustr*exp(-3.0e-4*p.z/ustr);
                if(usig<1.0e-5) usig=1.0e-5;
                vsig = 1.3*ustr*exp(-2.0e-4*p.z/ustr);
                if(vsig<1.0e-5) vsig=1.0e-5;
                wsig=vsig;

                dsw2 = -6.76e-4*ustr*exp(-4.0e-4*p.z/ustr);

                Tu=0.5*p.z/wsig/(1.0+1.5e-3*p.z/ustr);
                Tv=Tu;
                Tw=Tu;

            }

            else if(obkl < 0.0){ // Unstable condition
                usig = ustr*pow(12-0.5*hmix/obkl,1.0/3.0);
                if(usig<1.0e-6) usig=1.0e-6;
                vsig = usig;

                
                if(zeta < 0.03){
                    wsig = 0.9600*wstr*pow(3*zeta-obkl/hmix,1.0/3.0);
                    dsw2 = 1.8432*wstr*wstr/hmix*pow(3*zeta-obkl/hmix,-1.0/3.0);
                }
                else if(zeta < 0.40){
                    s1 = 0.9600*pow(3*zeta-obkl/hmix,1.0/3.0);
                    s2 = 0.7630*pow(zeta,0.175);
                    if(s1 < s2){
                        wsig = wstr*s1;
                        dsw2 = 1.8432*wstr*wstr/hmix*pow(3*zeta-obkl/hmix,-1.0/3.0);
                    }
                    else{
                        wsig = wstr*s2;
                        dsw2 = 0.203759*wstr*wstr/hmix*pow(zeta,-0.65);
                    }
                }
                else if(zeta < 0.96){
                    wsig = 0.722*wstr*pow(1-zeta,0.207);
                    dsw2 = -0.215812*wstr*wstr/hmix*pow(1-zeta,-0.586);
                }
                else if(zeta < 1.00){
                    wsig = 0.37*wstr;
                    dsw2 = 0.00;
                }

                if(wsig<1.0e-6) wsig=1.0e-6;

                Tu = 0.15*hmix/usig;
                Tv = Tu;

                if(p.z < abs(obkl)){
                    Tw = 0.1*p.z/(wsig*(0.55-0.38*abs(p.z/obkl)));
                } 
                else if(zeta < 0.1){
                    Tw = 0.59*p.z/wsig;
                }
                else{
                    Tw = 0.15*hmix/wsig*(1.0-exp(-5*zeta));
                }
            }

            else{ // Stable condition

                usig = 2.0*ustr*(1.0-zeta);
                vsig = 1.3*ustr*(1.0-zeta);
                if(usig<1.0e-6) usig=1.0e-6;
                if(vsig<1.0e-6) vsig=1.0e-6;
                wsig = vsig;

                dsw2 = 3.38*ustr*ustr*(zeta-1.0)/hmix;

                Tu = 0.15*hmix/usig*sqrt(zeta);
                Tv = 0.467*Tu;
                Tw = 0.1*hmix/wsig*pow(zeta,0.8);

            }

            if(Tu<10.0) Tu=10.0;
            if(Tv<10.0) Tv=10.0;
            if(Tw<30.0) Tw=30.0;

            float ux, uy, uz, rw;
            
            if(d_dt/Tu < 0.5) p.up = (1.0-d_dt/Tu)*p.up + curand_normal_double(&ss)*usig*sqrt(2.0*d_dt/Tu);
            else p.up = exp(-d_dt/Tu)*p.up + curand_normal_double(&ss)*usig*sqrt(1.0-exp(-d_dt/Tu)*exp(-d_dt/Tu));
                    
            if(d_dt/Tv < 0.5) p.vp = (1.0-d_dt/Tv)*p.vp + curand_normal_double(&ss)*vsig*sqrt(2.0*d_dt/Tv);
            else p.vp = exp(-d_dt/Tv)*p.vp + curand_normal_double(&ss)*vsig*sqrt(1.0-exp(-d_dt/Tv)*exp(-d_dt/Tv));    
        
            if(TURB_SWITCH){}
            else{
                rw = exp(-d_dt/Tw);
                float old_wp = p.wp;
                p.wp = (rw*p.wp + curand_normal_double(&ss)*sqrt(1.0-rw*rw)*wsig + Tw*(1.0-rw)*(dsw2+drho/rho*wsig*wsig))*p.dir;
                
                if (idx == 0) {
                    static int wp_debug_count = 0;
                    if (wp_debug_count < 3) {
                        printf("[WP_CALC] Particle 0: Tw=%.6f, rw=%.6f, old_wp=%.6f, wsig=%.6f, dsw2=%.6f, drho=%.6f, rho=%.6f, p.dir=%d, new_wp=%.6f (NaN=%d)\n", 
                               Tw, rw, old_wp, wsig, dsw2, drho, rho, p.dir, p.wp, isnan(p.wp));
                        wp_debug_count++;
                    }
                }
            }
            

            // Debug disabled for performance
            
            // if (p.wp*d_dt < -p.z){
            //     p.dir = -1;
            //     float old_z = p.z;
            //     p.z = -p.z - p.wp*d_dt;
            //     if (idx == 0) {
            //         static int reflect_debug1 = 0;
            //         if (reflect_debug1 < 3) {
            //             printf("[Z_REFLECT1] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
            //                    old_z, p.wp, d_dt, p.z, isnan(p.z));
            //             reflect_debug1++;
            //         }
            //     }
            // }
            // else if (p.wp*d_dt > (hmix-p.z)){
            //     p.dir = -1;
            //     float old_z = p.z;
            //     p.z = -p.z - p.wp*d_dt + 2.*hmix;
            //     if (idx == 0) {
            //         static int reflect_debug2 = 0;
            //         if (reflect_debug2 < 3) {
            //             printf("[Z_REFLECT2] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, hmix=%.6f, new_z=%.6f (NaN=%d)\n", 
            //                    old_z, p.wp, d_dt, hmix, p.z, isnan(p.z));
            //             reflect_debug2++;
            //         }
            //     }
            // }
            // else{
            //     p.dir = 1;
            //     p.z = p.z + p.wp*d_dt;
            //     if (idx == 0) {
            //         static int reflect_debug3 = 0;
            //         if (reflect_debug3 < 3) {
            //             printf("[Z_NORMAL] Particle 0: old_z=%.6f, wp=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
            //                    p.z - p.wp*d_dt, p.wp, d_dt, p.z, isnan(p.z));
            //             reflect_debug3++;
            //         }
            //     }
            // }



            //p.z += p.wp*d_dt;

            dx += xwind*d_dt;
            dy += ywind*d_dt;
            // dxt += p.up*d_dt;
            // dyt += p.vp*d_dt;
            float old_z_zwind = p.z;
            // p.z += zwind*d_dt;
            
            // Debug first particle z update for NaN tracking
            if (idx == 0) {
                static int z_debug_count = 0;
                if (z_debug_count < 3) {
                    printf("[Z_UPDATE1] Particle 0: old_z=%.6f, zwind=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                           old_z_zwind, zwind, d_dt, p.z, isnan(p.z));
                    z_debug_count++;
                }
            }

        }
        else{

            float ux, uy, uz;

            
            // if(p.z < trop){
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }
            // else if(p.z < trop+1000.0){
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }
            // else{
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = 0.0;
            // }

            ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            uz = 0.0;

            // if(p.z < trop){
            //     ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            //     uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt);
            //     uz = 0.0;
            // }
            // else if(p.z < trop+1000.0){
            //     ux = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt*(1-(p.z-trop)/1000.0));
            //     uy = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.0*d_trop/d_dt*(1-(p.z-trop)/1000.0));
            //     uz = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.*d_strat/d_dt*(p.z-trop)/1000.0)+d_strat/1000.0;
            // }
            // else{
            //     ux = 0.0;
            //     uy = 0.0;
            //     uz = GaussianRand(&ss, 0.0f, 1.0f)*sqrt(2.*d_strat/d_dt);
            // }
            

            dx += (xwind+ux)*d_dt;
            dy += (ywind+uy)*d_dt;
            float old_z_strat = p.z;
            p.z += (zwind+uz)*d_dt;
            
            // Debug second particle z update for NaN tracking
            if (idx == 0) {
                static int z_debug_count2 = 0;
                if (z_debug_count2 < 3) {
                    printf("[Z_UPDATE2] Particle 0: old_z=%.6f, zwind=%.6f, uz=%.6f, dt=%.6f, new_z=%.6f (NaN=%d)\n", 
                           old_z_strat, zwind, uz, d_dt, p.z, isnan(p.z));
                    z_debug_count2++;
                }
            }
            
            if(p.z<0.0) {
                float old_z_neg = p.z;
                p.z=-p.z;
                if (idx == 0) {
                    static int z_debug_count3 = 0;
                    if (z_debug_count3 < 3) {
                        printf("[Z_UPDATE3] Particle 0: negative z correction: %.6f -> %.6f (NaN=%d)\n", 
                               old_z_neg, p.z, isnan(p.z));
                        z_debug_count3++;
                    }
                }
            }

        }

        float r = exp(-2.0*d_dt/static_cast<float>(time_interval));
        float rs = sqrt(1.0-r*r);

        if(p.z<0.0) {
            float old_z_final_neg = p.z;
            p.z=-p.z;
        }

        
        float wind = sqrt(xwind*xwind+ywind*ywind);

        dx += xwind/wind*dxt-ywind/wind*dyt;
        dy += ywind/wind*dxt+xwind/wind*dyt;

        //printf("s1= %f, s2= %f\n", xwind/wind*dxt-ywind/wind*dyt, ywind/wind*dxt+xwind/wind*dyt);

        s1 = 180.0/(0.5*r_earth*PI);// dxconst, dyconst
        s2 = s1/cos((p.y*0.5-90.0)*PI180);// cosfact

        //printf("dx= %f, dy= %f, s1= %f, s2= %f\n", dx, dy, s1, s2);
        //printf("dx= %f, dy= %f\n", dx*s2, dy*s1);
        p.x += dx*s2; //!!
        p.y += dy*s1; //!!
        

        if(p.z > d_flex_hgt[dimZ_GFS-1]) {
            float old_z_clamp = p.z;
            p.z = d_flex_hgt[dimZ_GFS-1]*0.999999;
        }

        float prob = 0.0;
        float decfact = 1.0;
        float prob_dry = 0.0f;

        if (d_drydep && p.z < 2.0f * _href) {
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP enabled: z=%.2f, href=%.2f, vdep=%.6f\n", p.z, _href, vdep);
            // }
            float arg = -vdep * d_dt / (2.0f * _href);
            prob_dry = clamp01(1.0f - __expf(arg));
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP calculation: arg=%.6f, exp(arg)=%.6f, prob_dry=%.6f\n", arg, __expf(arg), prob_dry);
            // }
        } 
        //else if (idx == 0 && tstep <= 3) {
        //     printf("[GPU] DRYDEP disabled or z too high: d_drydep=%d, z=%.2f\n", d_drydep, p.z);
        // }

        float clouds_v, clouds_h;

        if(t0<=0.5) {
            clouds_v = device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].CLDS;
            clouds_h = device_meteorological_flex_unis0[(xidx) * dimY_GFS + (yidx)].CLDH;
        }
        else{
            clouds_v = device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].CLDS;
            clouds_h = device_meteorological_flex_unis1[(xidx) * dimY_GFS + (yidx)].CLDH;
        }

            float wet_removal = 0.0f;

            if (d_wetdep && (lsp >= 0.01f || convp >= 0.01f) && clouds_v > 1.0f) {
                // if (idx == 0 && tstep <= 3) {
                //     printf("[GPU] WETDEP enabled: lsp=%.3f, convp=%.3f, clouds=%.1f\n", lsp, convp, clouds_v);
                // }
                const float lfr[5] = {0.5f, 0.65f, 0.8f, 0.9f, 0.95f};
                const float cfr[5] = {0.4f, 0.55f, 0.7f, 0.8f, 0.9f};

                int weti = (lsp > 20.0f) ? 5 : (lsp > 8.0f) ? 4 : (lsp > 3.0f) ? 3 : (lsp > 1.0f) ? 2 : 1;
                int wetj = (convp > 20.0f) ? 5 : (convp > 8.0f) ? 4 : (convp > 3.0f) ? 3 : (convp > 1.0f) ? 2 : 1;

                float grfraction = 0.05f;
                if (lsp + convp > 0.0f) {
                    grfraction = fmaxf(0.05f, cc * (lsp * lfr[weti - 1] + convp * cfr[wetj - 1]) / (lsp + convp));
                }

                float prec = (lsp + convp) / grfraction;

                // 스캐빈징
                float wetscav = 0.0f;
                const float weta = 9.99999975e-5f;
                const float wetb = 0.800000012f;
                const float henry = p.drydep_vel;

                if (weta > 0.0f) {
                    if (clouds_v >= 4.0f) {
                        wetscav = weta * powf(prec, wetb);
                    } else {
                        float act_temp = (t0 <= 0.5f)
                            ? device_meteorological_flex_pres0[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].TT
                            : device_meteorological_flex_pres1[(xidx) * dimY_GFS * dimZ_GFS + (yidx) * dimZ_GFS + (zidx)].TT;
                        float cl = 2.0e-7f * powf(prec, 0.36f);
                        float S_i = (p.radi > 1.0e-10f)
                            ? (0.9f / cl)
                            : 1.0f / ((1.0f - cl) / (henry * (_rair / 3500.0f) * act_temp) + cl);
                        wetscav = S_i * prec / 3.6e6f / fmaxf(1.0f, clouds_h);
                    }
                }

                wet_removal = clamp01((1.0f - __expf(-wetscav * d_dt)) * grfraction);
            } 
            //else if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] WETDEP disabled or no precipitation: d_wetdep=%d, lsp=%.3f, convp=%.3f\n", d_wetdep, lsp, convp);
            // }

            if (d_raddecay) {
                // if (idx == 0 && tstep <= 5) {  // Only first particle, first few timesteps
                //     printf("[GPU] RADDECAY enabled: applying T matrix\n");
                // }
                //apply_T_once_rowmajor_60(T_const, p.concentrations);
                cram_decay_calculation(T_const, p.concentrations);
            } 
            // else if (idx == 0 && tstep <= 5) {
            //     printf("[GPU] RADDECAY disabled: skipping T matrix\n");
            // }


            if (d_wetdep && wet_removal > 0.0f) {
                #pragma unroll
                for (int i = 0; i < N_NUCLIDES; ++i) {
                    float c = p.concentrations[i];
                    if (c > 0.0f) p.concentrations[i] = c * (1.0f - wet_removal);
                }
            }


        if (d_drydep && prob_dry > 0.0f) {
            // if (idx == 0 && tstep <= 3) {
            //     printf("[GPU] DRYDEP applying: prob_dry=%.6f\n", prob_dry);
            // }
            
            #pragma unroll
            for (int i = 0; i < N_NUCLIDES; ++i) {
                float c = p.concentrations[i];
                if (c > 0.0f) p.concentrations[i] = c * (1.0f - prob_dry);
            }
            
        } 
        //else if (d_drydep && idx == 0 && tstep <= 3) {
        //     printf("[GPU] DRYDEP not applying: prob_dry=%.6f\n", prob_dry);
        // }


    float total = 0.0f;
    #pragma unroll
    for (int i = 0; i < N_NUCLIDES; ++i) {
        float c = p.concentrations[i];
        c = isfinite(c) ? c : 0.0f;
        c = fminf(c, 1e20f);
        // ALLOW NEGATIVE CONCENTRATIONS for EKI algorithm
        // c = fmaxf(c, 0.0f);  // REMOVED: Don't clamp to zero
        p.concentrations[i] = c;
        total += c;
    }
    // ALLOW NEGATIVE TOTAL for EKI algorithm
    // p.conc = fminf(fmaxf(total, 0.0f), 1e20f);  // REMOVED: Don't clamp to zero
    p.conc = isfinite(total) ? fminf(total, 1e20f) : 0.0f;
    

        // Safety checks for wind components
        p.u_wind = isnan(xwind) ? 0.0f : xwind;
        p.v_wind = isnan(ywind) ? 0.0f : ywind;
        p.w_wind = isnan(zwind) ? 0.0f : zwind;

        // Final debug only for critical check
        if (idx == 0) {
            static int final_debug_count = 0;
            if (final_debug_count < 5) {
                printf("[FINAL] Particle 0: z=%.3f (NaN=%d)\n", p.z, isnan(p.z));
                final_debug_count++;
            }
        }

        // DEBUG: Check concentrations for first 3 particles on EVERY kernel execution
        if (idx < 3) {
            printf("[GPU_ENS_INIT] P%d (ens=%d, timeidx=%d, flag=%d): conc=%.3e, conc[0]=%.3e, sum=%.3e\n",
                   idx, p.ensemble_id, p.timeidx, p.flag, p.conc, p.concentrations[0], total);
        }

}